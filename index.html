<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruin Delvers 2: Investigation of the Divine</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a2e; /* Dark background */
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column; /* Arrange children vertically */
            align-items: center; /* Center children horizontally */
            padding: 20px;
            background-color: #2e003a; /* Darker background for the container */
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5); /* Purple glow */
            max-width: 90%; /* Responsive width */
            max-height: 90vh; /* Responsive height */
            box-sizing: border-box; /* Include padding in width/height */
        }

        canvas {
            background-color: #0f0f1a; /* Slightly lighter dark for game area */
            display: block;
            border: 2px solid #00bfff; /* Neon blue border */
            border-radius: 15px; /* Rounded corners for the game area */
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.7); /* Glow effect */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            margin: 10px 0; /* Space between HUD and canvas */
            flex-shrink: 0; /* Prevent canvas from shrinking */
        }

        h1 {
            color: #e0e0e0;
            margin-bottom: 10px; /* Reduced margin */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            font-size: 2em; /* Adjust size for better fit */
        }

        .top-hud {
            width: 100%;
            display: flex;
            justify-content: space-between; /* Distribute items with space between */
            align-items: center;
            padding: 5px 0;
            box-sizing: border-box;
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
        }

        .hud-item {
            background-color: #444;
            padding: 5px 10px; /* Scaled down padding */
            border-radius: 8px;
            margin: 3px; /* Scaled down margin */
            font-size: 0.9em; /* Scaled down font size */
            font-weight: bold;
            color: #eee;
            min-width: 80px; /* Ensure minimum width for readability */
            text-align: center;
        }

        .health-bar-container {
            width: 150px; /* Scaled down width for the bar itself */
            height: 18px; /* Scaled down height */
            background-color: #555;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #fff;
            margin: 3px; /* Scaled down margin */
            display: flex; /* To center text inside */
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .health-bar-inner {
            height: 100%;
            background-color: #FF0000;
            width: 100%; /* Will be set by JS */
            transition: width 0.1s linear;
            position: absolute;
            left: 0;
            top: 0;
        }

        .health-bar-text {
            position: relative; /* To be on top of the inner bar */
            color: #fff;
            font-size: 0.8em; /* Scaled down font size */
            z-index: 1;
        }

        .timer-display {
            color: #00ff7f; /* Neon green for timer */
            font-size: 1.2em; /* Scaled down font size */
            text-shadow: 0 0 8px rgba(0, 255, 127, 0.6);
        }

        .exp-display {
            color: #ffd700; /* Gold for EXP */
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        .weapon-selector {
            display: flex;
            gap: 8px; /* Scaled down space between weapon icons */
            flex-wrap: wrap;
            justify-content: center;
        }

        .weapon-icon {
            width: 40px; /* Scaled down width */
            height: 40px; /* Scaled down height */
            background-color: #333;
            border: 2px solid #555;
            border-radius: 8px; /* Scaled down border-radius */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.6em; /* Scaled down emoji size */
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .weapon-icon:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .weapon-icon.selected {
            border-color: #00ff7f; /* Neon green highlight */
            box-shadow: 0 0 15px rgba(0, 255, 127, 0.7);
            transform: scale(1.05);
        }

        .controls-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #cccccc;
            text-align: center;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
        }

        .powerup-status {
            margin-top: 10px;
            font-size: 1em;
            color: #00ff7f; /* Neon green for active status */
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 127, 0.6);
            text-align: center;
            width: 100%;
        }

        /* Title Screen Styles */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e; /* Match body background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20; /* On top of everything */
            border-radius: 20px; /* Match game-container */
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
        }

        #titleScreen h2 {
            font-size: 2.5em;
            color: #00bfff; /* Neon blue title */
            text-shadow: 0 0 20px rgba(0, 191, 255, 0.8);
            margin-bottom: 40px;
            text-align: center;
        }

        #controlStyleSelection, #autoShootSelection {
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1em;
        }

        #controlStyleSelection label, #autoShootSelection label {
            margin: 0 15px;
            cursor: pointer;
        }

        #controlStyleSelection input[type="radio"], #autoShootSelection input[type="checkbox"] {
            margin-right: 5px;
        }

        #startButton {
            background-color: #00ff7f; /* Neon green */
            color: #1a1a2e;
            border: none;
            padding: 18px 40px;
            border-radius: 12px;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 255, 127, 0.4);
            margin-bottom: 30px;
        }

        #startButton:hover {
            background-color: #39ff14; /* Brighter green on hover */
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 255, 127, 0.6);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 255, 127, 0.3);
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e0e0e0;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 0, 0, 0.7); /* Red glow for game over */
            border-radius: 15px; /* Match canvas border radius */
            z-index: 10; /* Ensure it's on top */
            text-align: center;
        }

        .game-over-screen p {
            margin: 10px 0;
        }

        .restart-button {
            background-color: #00bfff; /* Neon blue */
            color: #1a1a2e;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.4);
            margin-top: 20px;
        }

        .restart-button:hover {
            background-color: #00e0ff; /* Lighter blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 191, 255, 0.6);
        }

        .restart-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 191, 255, 0.3);
        }

        /* 8-Direction Touch Overlay */
        #touchMovementOverlay {
            position: absolute;
            bottom: 20px; /* Position at the bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 150px; /* Size of the overlay */
            height: 150px;
            background-color: rgba(0, 0, 0, 0.4); /* Partially transparent black */
            border-radius: 50%; /* Make it circular */
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease;
            pointer-events: none; /* Allow clicks to pass through when hidden */
            z-index: 15; /* Above canvas, below title/game over */
        }

        #touchMovementOverlay.active {
            opacity: 1; /* Visible when active */
            pointer-events: all; /* Enable interaction when active */
        }

        #touchMovementOverlay > div {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            color: rgba(255, 255, 255, 0.7);
            user-select: none; /* Prevent text selection on touch */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        /* Specific grid areas for arrows */
        #touchMovementOverlay .up { grid-area: 1 / 2 / 2 / 3; }
        #touchMovementOverlay .up-left { grid-area: 1 / 1 / 2 / 2; }
        #touchMovementOverlay .up-right { grid-area: 1 / 3 / 2 / 4; }
        #touchMovementOverlay .left { grid-area: 2 / 1 / 3 / 2; }
        #touchMovementOverlay .right { grid-area: 2 / 3 / 3 / 4; }
        #touchMovementOverlay .down-left { grid-area: 3 / 1 / 4 / 2; }
        #touchMovementOverlay .down { grid-area: 3 / 2 / 4 / 3; }
        #touchMovementOverlay .down-right { grid-area: 3 / 3 / 4 / 4; }

        /* Media query for smaller screens to collapse title and scale HUD */
        @media (max-width: 600px) {
            h1 {
                font-size: 1.5em; /* Smaller main game title */
                margin-bottom: 5px;
            }

            #titleScreen h2 {
                font-size: 1.8em; /* Smaller title on title screen */
                margin-bottom: 20px;
            }

            .hud-item {
                padding: 3px 8px;
                font-size: 0.8em;
                min-width: 60px;
            }

            .health-bar-container {
                width: 120px;
                height: 16px;
            }

            .health-bar-text {
                font-size: 0.7em;
            }

            .timer-display {
                font-size: 1em;
            }

            .weapon-icon {
                width: 35px;
                height: 35px;
                font-size: 1.4em;
            }

            .controls-info p {
                font-size: 0.8em;
            }

            #touchMovementOverlay {
                width: 120px;
                height: 120px;
                bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 id="gameTitle">Ruin Delvers 2: Investigation of the Divine</h1>

        <!-- Title Screen -->
        <div id="titleScreen">
            <h2>Ruin Delvers 2: Investigation of the Divine</h2>
            <div id="controlStyleSelection">
                <p>Choose Control Style:</p>
                <label>
                    <input type="radio" name="controlStyle" value="pc" checked> PC-style
                </slabel>
                <label>
                    <input type="radio" name="controlStyle" value="phone"> Phone-style
                </label>
            </div>
            <div id="autoShootSelection">
                <label>
                    <input type="checkbox" id="autoShootToggle"> Auto-Shoot
                </label>
            </div>
            <button id="startButton">Start Game</button>
        </div>

        <div class="top-hud">
            <div class="hud-item health-bar-container">
                <div id="healthBarInner" class="health-bar-inner"></div>
                <span id="healthBarText" class="health-bar-text">Health: 100/100</span>
            </div>
            <div id="weaponSelectorContainer" class="weapon-selector"></div>
            <div id="timerDisplay" class="hud-item timer-display">Time: 2:00</div>
            <div id="expDisplay" class="hud-item exp-display">EXP: 0</div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls-info">
            <p><strong>Controls:</strong></p>
            <p>Move: <strong>W A S D</strong></p>
            <p>Aim: <strong>Mouse</strong></p>
            <p>Shoot: <strong>Left Click (Hold for continuous fire!)</strong></p>
            <p>Switch Weapon: <strong>Spacebar</strong></p>
        </div>
        <div id="powerupStatus" class="powerup-status" style="display: none;">
            RAPID FIRE ACTIVE!
        </div>

        <!-- 8-Direction Touch Movement Overlay -->
        <div id="touchMovementOverlay">
            <div class="up-left">â†–</div>
            <div class="up">â¬†</div>
            <div class="up-right">â†—</div>
            <div class="left">â¬…</div>
            <div class="center"></div> <!-- Center for no movement -->
            <div class="right">âž¡</div>
            <div class="down-left">â†™</div>
            <div class="down">â¬‡</div>
            <div class="down-right">â†˜</div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <p id="gameOverMessage">GAME OVER!</p>
            <p>Final EXP: <span id="finalScore">0</span></p>
            <button id="restartButton" class="restart-button">Back to Title</button>
        </div>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get HUD elements
        const powerupStatus = document.getElementById('powerupStatus');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const gameOverMessage = document.getElementById('gameOverMessage');

        // New HUD DOM elements
        const healthBarInner = document.getElementById('healthBarInner');
        const healthBarText = document.getElementById('healthBarText');
        const timerDisplay = document.getElementById('timerDisplay');
        const expDisplay = document.getElementById('expDisplay');
        const weaponSelectorContainer = document.getElementById('weaponSelectorContainer');

        // Title Screen elements
        const titleScreen = document.getElementById('titleScreen');
        const startButton = document.getElementById('startButton');
        const gameTitle = document.getElementById('gameTitle'); // Get the main game title element
        const controlStyleRadios = document.querySelectorAll('input[name="controlStyle"]');
        const autoShootToggle = document.getElementById('autoShootToggle'); // New auto-shoot toggle

        // Touch Movement Overlay elements
        const touchMovementOverlay = document.getElementById('touchMovementOverlay');

        // Player properties
        const player = {
            x: 0, // Initialized to 0, will be set correctly by setCanvasSize
            y: 0, // Initialized to 0, will be set correctly by setCanvasSize
            size: 30, // Base size for the frog
            speed: 5,
            color: '#32CD32', // Lime Green for the frog
            health: 100,
            maxHealth: 100
        };

        // Reticle properties
        const reticle = {
            x: 0, // Initialized to 0, will be set correctly by setCanvasSize
            y: 0, // Initialized to 0, will be set correctly by setCanvasSize
            size: 10,
            color: '#ff00ff' // Neon magenta
        };

        // Game state variables
        let gameState = 'title'; // 'title', 'playing', 'gameOver', or 'win'
        let score = 0;
        let currentControlStyle = 'pc'; // Default control style
        let autoShootingEnabled = false; // New state for auto-shooting

        // Set canvas dimensions (responsive)
        const setCanvasSize = () => {
            canvas.width = Math.min(window.innerWidth * 0.9, 800); // Max 800px width
            canvas.height = Math.min(window.innerHeight * 0.7, 600); // Max 600px height
            
            // Re-center player and reticle if canvas size changes
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            reticle.x = player.x; // Reticle starts at player position
            reticle.y = player.y;
        };

        // Array to hold active lasers (now projectiles)
        const projectiles = [];

        // Weapon definitions
        const weapons = [
            {
                name: 'laser',
                color: '#00ffff', // Cyan
                projectileSize: 5,
                projectileSpeed: 10, // Speed for laser projectile
                fireRateFactor: 1, // Base fire rate
                damage: 1,
                type: 'projectile', // 'projectile' or 'aoe'
                draw: (ctx, p) => { // Needle shape
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.dirY, p.dirX)); // Rotate to direction of travel
                    ctx.fillRect(-p.size * 2, -p.size / 2, p.size * 4, p.size); // Long thin rectangle
                    ctx.restore();
                },
                icon: 'â€¢' // Bullet-like icon
            },
            {
                name: 'electric',
                color: '#ffdd00', // Yellow
                projectileSize: 3,
                projectileSpeed: 12, // Speed for electric projectile
                fireRateFactor: 2, // Faster firing
                damage: 0.5, // Less damage per shot
                spreadCount: 5, // Number of shots in spread
                spreadAngle: Math.PI / 8, // Angle of spread
                type: 'projectile',
                draw: (ctx, p) => { // Small circle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                },
                icon: 'âš¡' // Emoji icon for electric
            },
            {
                name: 'frost',
                color: '#87ceeb', // Sky Blue
                projectileSize: 15, // Larger projectile
                projectileSpeed: 7, // Slower speed for frost projectile
                fireRateFactor: 0.5, // Slower firing
                damage: 2,
                effect: 'slow',
                effectDuration: 3000, // 3 seconds slow
                slowFactor: 0.5, // Reduce enemy speed by 50%
                type: 'projectile',
                draw: (ctx, p) => { // Large blue circle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                },
                icon: 'â„ï¸' // Emoji icon for frost
            },
            {
                name: 'ignition',
                color: '#ff4500', // Orange Red
                projectileSize: 7,
                projectileSpeed: 9, // Speed for ignition projectile
                fireRateFactor: 0.7, // Slower firing
                damage: 1, // Initial damage
                effect: 'burn',
                burnDuration: 4000, // 4 seconds burn
                burnDamagePerTick: 0.2, // Damage per tick
                burnTickInterval: 200, // Every 200ms
                type: 'projectile',
                draw: (ctx, p) => { // Fiery circle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                },
                icon: 'ðŸ”¥' // Emoji icon for ignition
            },
            {
                name: 'spout',
                color: '#00bfff', // Deep Sky Blue
                projectileSize: 40, // Area of effect radius
                projectileSpeed: 0, // AOE doesn't move
                fireRateFactor: 0.3, // Very slow firing
                damage: 5, // Damage per enemy in area
                type: 'aoe', // Area of effect weapon
                draw: (ctx, p) => { // Pulsating circle for AOE
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (0.5 + 0.5 * Math.sin(performance.now() / 100)), 0, Math.PI * 2); // Pulsating effect
                    ctx.fill();
                },
                icon: 'ðŸ’§' // Emoji icon for spout
            }
        ];

        let currentWeaponIndex = 0;
        let currentWeapon = weapons[currentWeaponIndex];

        // Firing rate properties
        let baseFireRate = currentWeapon.fireRateFactor * 8; // Adjust base fire rate by weapon factor
        let rapidFireRate = currentWeapon.fireRateFactor * 20; // Adjust rapid fire rate by weapon factor
        let currentFireRate = baseFireRate;
        let lastShotTime = 0; // Timestamp of the last shot
        let rapidFireActive = false;
        let rapidFireTimeoutId = null; // To clear the timeout

        // Power-up object properties
        const powerup = {
            x: 0,
            y: 0,
            size: 20,
            color: '#FFFF00', // Yellow
            active: false,
            spawnDelay: 5000, // 5 seconds before next spawn
            lastCollectedTime: 0
        };

        // Enemy properties
        const enemies = [];
        let enemySpawnInterval = 2000; // Initial spawn interval
        let lastEnemySpawnTime = 0;
        const enemyBaseSpeed = 1.5; // Base speed for enemies
        const enemyBaseSize = 25; // Base size for enemies
        const playerDamagePerCollision = 20; // Damage player takes per enemy collision

        // AI constants
        const ZOMBIE_TARGET_RETENTION_DURATION = 1500; // ms
        const DRAGON_EVASION_STRENGTH = 0.8; // How much the dragon tries to evade (0-1)
        const GHOST_WAVE_AMPLITUDE = 20; // Max pixels for side-to-side movement
        const GHOST_WAVE_FREQUENCY = 0.005; // How fast the wave oscillates (smaller is faster)
        const BONE_DEVIL_CHARGE_DURATION = 800; // ms
        const BONE_DEVIL_PAUSE_DURATION = 1000; // ms
        const BONE_DEVIL_CHARGE_SPEED_MULTIPLIER = 2.5; // How much faster it charges

        // Difficulty Scaling Constants
        const initialGameTime = 120; // 2 minutes in seconds
        let gameTimer = initialGameTime;
        let gameStartTime = 0; // To store performance.now() when game starts

        const minSpawnInterval = 500; // Fastest spawn interval (at 0 seconds)
        const maxSpawnInterval = 2000; // Slowest spawn interval (at initialGameTime)

        const minGlobalSpeedMultiplier = 1; // Base speed multiplier (at initialGameTime)
        const maxGlobalSpeedMultiplier = 2; // Max speed multiplier (at 0 seconds)
        let currentGlobalSpeedMultiplier = minGlobalSpeedMultiplier;


        // Define different enemy types with their health, size, speed, points, and AI type
        const enemyTypes = [
            { name: 'ghost', health: 3, sizeFactor: 1, speedFactor: 1, points: 10, aiType: 'ghost_wavy' },
            { name: 'zombie', health: 5, sizeFactor: 1.2, speedFactor: 0.8, points: 20, aiType: 'zombie_wander' },
            { name: 'skull', health: 2, sizeFactor: 0.8, speedFactor: 1.5, points: 5, aiType: 'direct' },
            { name: 'boneDevil', health: 7, sizeFactor: 1.3, speedFactor: 1.1, points: 30, aiType: 'bone_devil_charge' },
            { name: 'boneDragon', health: 10, sizeFactor: 1.5, speedFactor: 0.7, points: 50, aiType: 'dragon_evade' }
        ];

        // Palette of colors for enemies
        const enemyColors = [
            '#b0c4de', // Light steel blue
            '#a9a9a9', // Dark gray
            '#808080', // Gray
            '#696969', // Dim gray
            '#d3d3d3', // Light gray
            '#f0f8ff', // Alice blue (almost white, for ghostly)
            '#add8e6', // Light blue
            '#90ee90', // Light green (decaying)
            '#ffb6c1', // Light pink (flesh, but desaturated)
            '#deb887',  // Burly wood (bone-like)
            '#c0c0c0', // Silver
            '#708090', // Slate Gray
            '#4682b4', // Steel Blue
            '#b22222'  // Firebrick
        ];

        // Function to get a random color from the palette
        function getRandomColor() {
            return enemyColors[Math.floor(Math.random() * enemyColors.length)];
        }

        // Keyboard input state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false // Added for weapon switching
        };

        // Mouse input state
        let mouse = {
            x: 0,
            y: 0,
            isMouseDown: false
        };

        // --- Event Listeners ---

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return; // Only allow input when playing
            if (e.key === 'w' || e.key === 'W') keys.w = true;
            if (e.key === 'a' || e.key === 'A') keys.a = true;
            if (e.key === 's' || e.key === 'S') keys.s = true;
            if (e.key === 'd' || e.key === 'D') keys.d = true;
            if (e.code === 'Space' && !keys.space) { // Only trigger once per press
                keys.space = true;
                switchWeapon();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState !== 'playing') return; // Only allow input when playing
            if (e.key === 'w' || e.key === 'W') keys.w = false;
            if (e.key === 'a' || e.key === 'A') keys.a = false;
            if (e.key === 's' || e.key === 'S') keys.s = false;
            if (e.key === 'd' || e.key === 'D') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });

        // Mouse movement for reticle
        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'playing') return; // Only allow input when playing
            // Get mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            reticle.x = e.clientX - rect.left;
            reticle.y = e.clientY - rect.top;
        });

        // Mouse click for shooting (continuous firing handled in gameLoop)
        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'playing') return; // Only allow input when playing
            if (!autoShootingEnabled && e.button === 0) { // Only if auto-shooting is OFF and left click
                mouse.isMouseDown = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState !== 'playing') return; // Only allow input when playing
            if (!autoShootingEnabled && e.button === 0) { // Only if auto-shooting is OFF and left click
                mouse.isMouseDown = false;
            }
        });

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault(); // Prevent scrolling/zooming
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            reticle.x = touch.clientX - rect.left; // Update reticle on touch
            reticle.y = touch.clientY - rect.top;
            
            if (currentControlStyle === 'pc' && !autoShootingEnabled) { // For PC-style, if auto-shoot is OFF
                mouse.isMouseDown = true; // Activate continuous firing on touch start
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            reticle.x = touch.clientX - rect.left; // Update reticle position based on touch move
            reticle.y = touch.clientY - rect.top;

            if (currentControlStyle === 'pc') { // Only PC-style uses touch for player movement
                // Simple player movement based on touch drag relative to player
                const dx = (touch.clientX - rect.left) - player.x;
                const dy = (touch.clientY - rect.top) - player.y;

                // Normalize direction for movement
                const angle = Math.atan2(dy, dx);
                keys.d = Math.abs(Math.cos(angle)) > 0.5 && Math.cos(angle) > 0;
                keys.a = Math.abs(Math.cos(angle)) > 0.5 && Math.cos(angle) < 0;
                keys.s = Math.abs(Math.sin(angle)) > 0.5 && Math.sin(angle) > 0;
                keys.w = Math.abs(Math.sin(angle)) > 0.5 && Math.sin(angle) < 0;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') return;
            if (currentControlStyle === 'pc' && !autoShootingEnabled) { // For PC-style, if auto-shoot is OFF
                keys.w = keys.a = keys.s = keys.d = false; // Stop movement
                mouse.isMouseDown = false; // Stop firing
            }
        });

        // Touch movement overlay listeners (for Phone-style)
        touchMovementOverlay.addEventListener('touchstart', (e) => {
            if (gameState !== 'playing' || currentControlStyle !== 'phone') return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = touchMovementOverlay.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            handleTouchMovement(x, y, rect.width, rect.height);
        });

        touchMovementOverlay.addEventListener('touchmove', (e) => {
            if (gameState !== 'playing' || currentControlStyle !== 'phone') return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = touchMovementOverlay.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            handleTouchMovement(x, y, rect.width, rect.height);
        });

        touchMovementOverlay.addEventListener('touchend', (e) => {
            if (gameState !== 'playing' || currentControlStyle !== 'phone') return;
            e.preventDefault();
            keys.w = keys.a = keys.s = keys.d = false; // Stop movement
        });

        function handleTouchMovement(x, y, width, height) {
            // Determine direction based on touch position within the 3x3 grid
            const col = Math.floor(x / (width / 3));
            const row = Math.floor(y / (height / 3));

            keys.w = false;
            keys.a = false;
            keys.s = false;
            keys.d = false;

            if (row === 0) keys.w = true; // Top row: Up
            if (row === 2) keys.s = true; // Bottom row: Down
            if (col === 0) keys.a = true; // Left column: Left
            if (col === 2) keys.d = true; // Right column: Right
        }


        // Restart button listener (now "Back to Title")
        restartButton.addEventListener('click', () => {
            // Hide game over screen
            gameOverScreen.style.display = 'none';
            // Show title screen and game title
            titleScreen.style.display = 'flex';
            gameTitle.style.display = 'block'; // Show the main game title
            // Hide touch movement overlay
            touchMovementOverlay.classList.remove('active');
            gameState = 'title'; // Set game state back to title
        });

        // Start Button listener for Title Screen
        startButton.addEventListener('click', () => {
            startGame();
        });

        // --- Game Functions ---

        // Function to draw the player (frog with moving eyes!)
        function drawPlayer() {
            ctx.fillStyle = player.color;

            // Draw frog body (main ellipse) - centered at player.x, player.y
            ctx.beginPath();
            ctx.ellipse(player.x, player.y, player.size * 0.7, player.size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Frog eye properties
            const eyeRadius = player.size * 0.2;
            const eyeOffsetX = player.size * 0.3;
            const eyeOffsetY = -player.size * 0.4; // Eyes are above the body relative to player.y

            // Left eye stalk position
            const leftEyeX = player.x - eyeOffsetX;
            const leftEyeY = player.y + eyeOffsetY;

            // Right eye stalk position
            const rightEyeX = player.x + eyeOffsetX;
            const rightEyeY = player.y + eyeOffsetY;

            // Draw left eye stalk
            ctx.beginPath();
            ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw right eye stalk
            ctx.beginPath();
            ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw pupils (black circles)
            ctx.fillStyle = 'black';
            const pupilRadius = eyeRadius * 0.4;
            const maxPupilOffset = eyeRadius - pupilRadius; // Max distance pupil can move from eye center

            // Calculate angle from player to reticle (for pupil direction)
            const angleToReticle = Math.atan2(reticle.y - player.y, reticle.x - player.x);

            // Calculate pupil offset based on angle
            const pupilDx = Math.cos(angleToReticle) * maxPupilOffset;
            const pupilDy = Math.sin(angleToReticle) * maxPupilOffset;

            // Draw left pupil
            ctx.beginPath();
            ctx.arc(leftEyeX + pupilDx, leftEyeY + pupilDy, pupilRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw right pupil
            ctx.beginPath();
            ctx.arc(rightEyeX + pupilDx, rightEyeY + pupilDy, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Function to draw the reticle
        function drawReticle() {
            ctx.strokeStyle = reticle.color;
            ctx.lineWidth = 2;

            // Draw a crosshair reticle
            ctx.beginPath();
            ctx.moveTo(reticle.x - reticle.size, reticle.y);
            ctx.lineTo(reticle.x + reticle.size, reticle.y);
            ctx.moveTo(reticle.x, reticle.y - reticle.size);
            ctx.lineTo(reticle.x, reticle.y + reticle.size);
            ctx.stroke();

            // Draw a small circle in the center
            ctx.beginPath();
            ctx.arc(reticle.x, reticle.y, reticle.size / 3, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Function to draw the power-up
        function drawPowerup() {
            if (powerup.active) {
                ctx.fillStyle = powerup.color;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, powerup.size, 0, Math.PI * 2);
                ctx.fill();

                // Add a pulsating glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = powerup.color;
                ctx.globalAlpha = 0.8 + 0.2 * Math.sin(performance.now() / 200); // Pulsating effect
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
                ctx.globalAlpha = 1; // Reset alpha
            }
        }

        // --- Drawing functions for different enemy types ---

        function drawGhostShape(ctx, enemy) {
            const bodyWidth = enemy.size * 1.5;
            const bodyHeight = enemy.size * 1.8;
            const bottomCurveRadius = enemy.size * 0.5;

            ctx.beginPath();
            // Top rectangle part
            ctx.moveTo(enemy.x - bodyWidth / 2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x + bodyWidth / 2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x + bodyWidth / 2, enemy.y + bodyHeight / 2 - bottomCurveRadius);

            // Bottom curves (scallops)
            const numScallops = 3;
            const scallopWidth = bodyWidth / numScallops;
            for (let i = 0; i < numScallops; i++) {
                const startX = enemy.x - bodyWidth / 2 + i * scallopWidth;
                ctx.arc(startX + scallopWidth / 2, enemy.y + bodyHeight / 2 - bottomCurveRadius, scallopWidth / 2, 0, Math.PI, true);
            }
            ctx.lineTo(enemy.x - bodyWidth / 2, enemy.y + bodyHeight / 2 - bottomCurveRadius);
            ctx.closePath();
            ctx.fill();

            // Draw ghost eyes (simple circles)
            ctx.fillStyle = 'black';
            const eyeRadius = enemy.size * 0.2;
            ctx.beginPath();
            ctx.arc(enemy.x - enemy.size * 0.4, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + enemy.size * 0.4, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawZombieShape(ctx, enemy) {
            const bodyWidth = enemy.size * 1.2;
            const bodyHeight = enemy.size * 1.8;
            const headSize = enemy.size * 0.8;

            // Body
            ctx.beginPath();
            ctx.rect(enemy.x - bodyWidth / 2, enemy.y - bodyHeight / 2, bodyWidth, bodyHeight);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y - bodyHeight / 2 - headSize / 2, headSize / 2, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'darkred';
            const eyeRadius = headSize * 0.15;
            ctx.beginPath();
            ctx.arc(enemy.x - headSize * 0.25, enemy.y - bodyHeight / 2 - headSize / 2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + headSize * 0.25, enemy.y - bodyHeight / 2 - headSize / 2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (simple line)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(enemy.x - headSize * 0.2, enemy.y - bodyHeight / 2 - headSize / 2 + headSize * 0.2);
            ctx.lineTo(enemy.x + headSize * 0.2, enemy.y - bodyHeight / 2 - headSize / 2 + headSize * 0.2);
            ctx.stroke();
        }

        function drawSkullShape(ctx, enemy) {
            const skullRadius = enemy.size * 0.8;
            const jawHeight = enemy.size * 0.4;

            // Skull head
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y - jawHeight / 2, skullRadius, 0, Math.PI * 2);
            ctx.fill();

            // Jaw (simple rectangle)
            ctx.beginPath();
            ctx.rect(enemy.x - skullRadius * 0.7, enemy.y - jawHeight / 2 + skullRadius * 0.8, skullRadius * 1.4, jawHeight);
            ctx.fill();

            // Eye sockets
            ctx.fillStyle = 'black';
            const eyeSocketRadius = skullRadius * 0.25;
            ctx.beginPath();
            ctx.arc(enemy.x - skullRadius * 0.35, enemy.y - jawHeight / 2 - skullRadius * 0.2, eyeSocketRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + skullRadius * 0.35, enemy.y - jawHeight / 2 - skullRadius * 0.2, eyeSocketRadius, 0, Math.PI * 2);
            ctx.fill();

            // Nose hole (triangle)
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - jawHeight / 2 + skullRadius * 0.2);
            ctx.lineTo(enemy.x - skullRadius * 0.1, enemy.y - jawHeight / 2 + skullRadius * 0.4);
            ctx.lineTo(enemy.x + skullRadius * 0.1, enemy.y - jawHeight / 2 + skullRadius * 0.4);
            ctx.closePath();
            ctx.fill();
        }

        function drawBoneDevilShape(ctx, enemy) {
            const bodyWidth = enemy.size * 1.6;
            const bodyHeight = enemy.size * 1.5;
            const hornLength = enemy.size * 0.7;

            // Main body (trapezoid/diamond-like)
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - bodyHeight / 2); // Top point
            ctx.lineTo(enemy.x + bodyWidth / 2, enemy.y); // Right point
            ctx.lineTo(enemy.x, enemy.y + bodyHeight / 2); // Bottom point
            ctx.lineTo(enemy.x - bodyWidth / 2, enemy.y); // Left point
            ctx.closePath();
            ctx.fill();

            // Horns
            ctx.beginPath();
            ctx.moveTo(enemy.x - bodyWidth * 0.2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x - bodyWidth * 0.2 - hornLength * 0.5, enemy.y - bodyHeight / 2 - hornLength);
            ctx.lineTo(enemy.x - bodyWidth * 0.2 + hornLength * 0.2, enemy.y - bodyHeight / 2);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(enemy.x + bodyWidth * 0.2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x + bodyWidth * 0.2 + hornLength * 0.5, enemy.y - bodyHeight / 2 - hornLength);
            ctx.lineTo(enemy.x + bodyWidth * 0.2 - hornLength * 0.2, enemy.y - bodyHeight / 2);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'red'; // Fiery eyes
            const eyeRadius = enemy.size * 0.15;
            ctx.beginPath();
            ctx.arc(enemy.x - enemy.size * 0.3, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + enemy.size * 0.3, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBoneDragonShape(ctx, enemy) {
            const bodyLength = enemy.size * 3;
            const bodyHeight = enemy.size * 0.8;
            const headRadius = enemy.size * 0.6;

            // Body (elongated ellipse)
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y, bodyLength / 2, bodyHeight / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (at one end of the body)
            ctx.beginPath();
            ctx.arc(enemy.x + bodyLength / 2 - headRadius * 0.5, enemy.y - headRadius * 0.2, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Spikes along the back
            ctx.fillStyle = enemy.color; // Use body color for spikes
            const numSpikes = 5;
            for (let i = 0; i < numSpikes; i++) {
                const spikeX = enemy.x - bodyLength / 2 + (i + 0.5) * (bodyLength / numSpikes);
                const spikeY = enemy.y - bodyHeight / 2;
                const spikeHeight = enemy.size * 0.4;
                const spikeWidth = enemy.size * 0.2;

                ctx.beginPath();
                ctx.moveTo(spikeX - spikeWidth / 2, spikeY);
                ctx.lineTo(spikeX + spikeWidth / 2, spikeY);
                ctx.lineTo(spikeX, spikeY - spikeHeight);
                ctx.closePath();
                ctx.fill();
            }

            // Eyes
            ctx.fillStyle = 'darkred';
            const eyeRadius = headRadius * 0.15;
            ctx.beginPath();
            ctx.arc(enemy.x + bodyLength / 2 - headRadius * 0.5 - headRadius * 0.2, enemy.y - headRadius * 0.2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + bodyLength / 2 - headRadius * 0.5 + headRadius * 0.2, enemy.y - headRadius * 0.2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Main function to draw an enemy based on its type
        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.globalAlpha = 1; // Ensure full opacity for enemies

            switch (enemy.type) {
                case 'ghost':
                    drawGhostShape(ctx, enemy);
                    break;
                case 'zombie':
                    drawZombieShape(ctx, enemy);
                    break;
                case 'skull':
                    drawSkullShape(ctx, enemy);
                    break;
                case 'boneDevil':
                    drawBoneDevilShape(ctx, enemy);
                    break;
                case 'boneDragon':
                    drawBoneDragonShape(ctx, enemy);
                    break;
                default:
                    // Fallback: draw a simple circle if type is unknown
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }


        // Function to fire the current weapon
        function fireWeapon() {
            const currentTime = performance.now();
            const timeSinceLastShot = currentTime - lastShotTime;
            const requiredTimeBetweenShots = 1000 / currentFireRate; // Milliseconds per shot

            // Only fire if enough time has passed since the last shot
            if (timeSinceLastShot >= requiredTimeBetweenShots) {
                // Calculate direction vector from player to reticle
                const dx = reticle.x - player.x;
                const dy = reticle.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Normalize the direction vector
                const dirX = dx / distance;
                const dirY = dy / distance;

                if (currentWeapon.type === 'projectile') {
                    if (currentWeapon.name === 'electric') {
                        // Electric: multiple spread shots
                        const numShots = currentWeapon.spreadCount;
                        const baseAngle = Math.atan2(dirY, dirX);
                        for (let i = 0; i < numShots; i++) {
                            const angleOffset = (i - (numShots - 1) / 2) * (currentWeapon.spreadAngle / numShots);
                            const newAngle = baseAngle + angleOffset;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                dirX: Math.cos(newAngle),
                                dirY: Math.sin(newAngle),
                                color: currentWeapon.color,
                                size: currentWeapon.projectileSize,
                                speed: currentWeapon.projectileSpeed, // Assign projectile speed
                                damage: currentWeapon.damage,
                                type: currentWeapon.name,
                                effect: currentWeapon.effect // Will be undefined for electric, which is fine
                            });
                        }
                    } else {
                        // Default projectile (laser, frost, ignition)
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            dirX: dirX,
                            dirY: dirY,
                            color: currentWeapon.color,
                            size: currentWeapon.projectileSize,
                            speed: currentWeapon.projectileSpeed, // Assign projectile speed
                            damage: currentWeapon.damage,
                            type: currentWeapon.name,
                            effect: currentWeapon.effect // For frost/ignition
                        });
                    }
                } else if (currentWeapon.type === 'aoe' && currentWeapon.name === 'spout') {
                    // Spout: instantaneous AOE at reticle
                    // No projectile, directly apply damage to enemies in area
                    enemies.forEach(enemy => {
                        if (checkCollision(enemy, {x: reticle.x, y: reticle.y, size: currentWeapon.projectileSize})) {
                            enemy.health -= currentWeapon.damage;
                            // Add visual feedback for AOE hit (e.g., temporary particle effect)
                            // For now, just a console log
                            console.log(`Enemy hit by Spout: ${enemy.type}, new health: ${enemy.health}`);
                        }
                    });
                    // Add a temporary visual effect for spout at the reticle
                    projectiles.push({
                        x: reticle.x,
                        y: reticle.y,
                        size: currentWeapon.projectileSize,
                        color: currentWeapon.color,
                        type: 'spout_effect', // Special type for drawing only
                        duration: 200 // How long the visual effect lasts
                    });
                }

                lastShotTime = currentTime; // Update last shot time
            }
        }

        // Function to activate rapid fire power-up
        function activateRapidFire(duration) {
            if (rapidFireActive) {
                clearTimeout(rapidFireTimeoutId); // Clear any existing timeout if power-up is re-activated
            }

            // Calculate rapid fire rate based on current weapon's factor
            currentFireRate = currentWeapon.fireRateFactor * rapidFireRate;
            rapidFireActive = true;
            powerupStatus.style.display = 'block'; // Show status message

            // Set a timeout to revert to base fire rate after duration
            rapidFireTimeoutId = setTimeout(() => {
                currentFireRate = currentWeapon.fireRateFactor * baseFireRate; // Revert to base rate
                rapidFireActive = false;
                powerupStatus.style.display = 'none'; // Hide status message
            }, duration);
        }

        // Function to switch weapon
        function switchWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % weapons.length;
            currentWeapon = weapons[currentWeaponIndex];
            // Update fire rate based on new weapon's factor
            currentFireRate = rapidFireActive ? currentWeapon.fireRateFactor * rapidFireRate : currentWeapon.fireRateFactor * baseFireRate;
            renderWeaponSelector(); // Update HUD
        }


        // Function to spawn a power-up at a random location
        function spawnPowerup() {
            if (!powerup.active) { // Only spawn if not already active
                powerup.x = Math.random() * (canvas.width - powerup.size * 2) + powerup.size;
                powerup.y = Math.random() * (canvas.height - powerup.size * 2) + powerup.size;
                powerup.active = true;
            }
        }

        // Function to spawn an enemy from off-screen
        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y;

            const chosenType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            // Adjust spawn position based on the actual size of the enemy to ensure it's fully off-screen
            const spawnOffset = enemyBaseSize * chosenType.sizeFactor * 2; // Use actual size for offset

            switch (side) {
                case 0: // Top
                    x = Math.random() * canvas.width;
                    y = -spawnOffset;
                    break;
                case 1: // Right
                    x = canvas.width + spawnOffset;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // Bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + spawnOffset;
                    break;
                case 3: // Left
                    x = -spawnOffset;
                    y = Math.random() * canvas.height;
                    break;
            }

            const newEnemy = {
                x: x,
                y: y,
                size: enemyBaseSize * chosenType.sizeFactor, // Apply size factor
                color: getRandomColor(),
                speed: enemyBaseSpeed * chosenType.speedFactor, // Apply speed factor
                health: chosenType.health,
                type: chosenType.name, // Store the type name for drawing
                points: chosenType.points, // Store points for scoring
                aiType: chosenType.aiType, // Store the AI type
                originalSpeed: enemyBaseSpeed * chosenType.speedFactor, // Store original speed for dynamic scaling
                // Status effects
                isSlowed: false,
                slowTimer: 0,
                isBurning: false,
                burnTimer: 0,
                burnDamagePerTick: 0,
                lastBurnTickTime: 0
            };

            // Initialize AI-specific properties
            if (newEnemy.aiType === 'zombie_wander') {
                newEnemy.lastKnownPlayerX = player.x;
                newEnemy.lastKnownPlayerY = player.y;
                newEnemy.reacquireTargetTime = performance.now() + ZOMBIE_TARGET_RETENTION_DURATION;
            } else if (newEnemy.aiType === 'bone_devil_charge') {
                newEnemy.aiState = 'moving'; // Initial state
                newEnemy.stateTimer = performance.now(); // Start timer
            } else if (newEnemy.aiType === 'ghost_wavy') {
                newEnemy.waveOffset = Math.random() * Math.PI * 2; // Random starting point for wave
            }


            enemies.push(newEnemy);
        }

        // Function to check for collision between two circles
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size + obj2.size); // Collision if distance is less than sum of radii
        }

        // Function to reset game state for a new game
        function resetGame() {
            player.health = player.maxHealth;
            // Ensure player position is set after canvas size is determined
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            reticle.x = player.x;
            reticle.y = player.y;

            score = 0;
            enemies.length = 0; // Clear all enemies
            projectiles.length = 0; // Clear all projectiles
            powerup.active = false; // Deactivate power-up
            currentWeaponIndex = 0; // Reset to default weapon
            currentWeapon = weapons[currentWeaponIndex];
            
            // Set initial fire rate based on new auto-shooting toggle
            currentFireRate = currentWeapon.fireRateFactor * baseFireRate;
            mouse.isMouseDown = autoShootingEnabled; // Set shooting state based on toggle

            rapidFireActive = false;
            if (rapidFireTimeoutId) clearTimeout(rapidFireTimeoutId);
            powerupStatus.style.display = 'none';
            gameOverScreen.style.display = 'none';
            gameState = 'playing'; // Set game state to playing
            gameTimer = initialGameTime; // Reset game timer
            gameStartTime = performance.now(); // Reset game start time
            gameOverMessage.textContent = 'GAME OVER!'; // Reset message
            
            updateHUD(); // Initial HUD update
            renderWeaponSelector(); // Initial weapon selector render
            // Spawn initial power-up after a short delay
            setTimeout(spawnPowerup, 1000);
        }

        // Function to start the game from the title screen
        function startGame() {
            // Get selected control style and auto-shoot preference
            currentControlStyle = document.querySelector('input[name="controlStyle"]:checked').value;
            autoShootingEnabled = autoShootToggle.checked;
            console.log("Selected Control Style:", currentControlStyle);
            console.log("Auto-Shooting Enabled:", autoShootingEnabled);

            titleScreen.style.display = 'none'; // Hide title screen
            gameTitle.style.display = 'none'; // Hide the main game title when playing
            
            // Show game elements
            const topHud = document.querySelector('.top-hud');
            const controlsInfo = document.querySelector('.controls-info');

            topHud.style.display = 'flex';
            
            // Show/hide touch movement overlay and controls info based on control style
            if (currentControlStyle === 'phone') {
                touchMovementOverlay.classList.add('active');
                controlsInfo.style.display = 'none'; // Hide text controls info for phone style
            } else {
                touchMovementOverlay.classList.remove('active');
                controlsInfo.style.display = 'block'; // Show text controls info for PC style
            }

            canvas.style.display = 'block';

            resetGame(); // Reset and start the game
        }

        // Function to update game state (movement, projectile positions, power-up, enemies)
        function update() {
            if (gameState !== 'playing') return; // Do not update if game is not playing

            const currentTime = performance.now();
            const elapsedTime = (currentTime - gameStartTime) / 1000; // Time in seconds
            gameTimer = Math.max(0, initialGameTime - elapsedTime);

            // Check for win condition
            if (gameTimer <= 0) {
                gameState = 'win';
                gameOverMessage.textContent = 'YOU WIN!';
                finalScoreDisplay.textContent = score;
                gameOverScreen.style.display = 'flex';
                // Hide game elements when game is over/won
                document.querySelector('.top-hud').style.display = 'none';
                document.querySelector('.controls-info').style.display = 'none';
                canvas.style.display = 'none';
                gameTitle.style.display = 'block'; // Show title again on game over/win
                touchMovementOverlay.classList.remove('active'); // Hide touch overlay
                return; // Stop updating game state
            }

            // Difficulty Scaling based on timer progress (0 to 1 as time goes from initial to 0)
            const difficultyProgress = 1 - (gameTimer / initialGameTime);
            enemySpawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * difficultyProgress;
            currentGlobalSpeedMultiplier = minGlobalSpeedMultiplier + (maxGlobalSpeedMultiplier - minGlobalSpeedMultiplier) * difficultyProgress;


            // Update player position based on keys pressed
            if (keys.w) player.y -= player.speed;
            if (keys.s) player.y += player.speed;
            if (keys.a) player.x -= player.speed;
            if (keys.d) player.x += player.speed;

            // Keep player within canvas bounds
            player.x = Math.max(player.size * 0.7, Math.min(canvas.width - player.size * 0.7, player.x));
            player.y = Math.max(player.size * 0.5, Math.min(canvas.height - player.size * 0.5, player.y));


            // If mouse is down, continuously try to fire weapon
            if (mouse.isMouseDown) {
                fireWeapon();
            }

            // Update projectile positions
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];

                if (p.type === 'spout_effect') {
                    p.duration -= 16; // Assuming 60fps, roughly 16ms per frame
                    if (p.duration <= 0) {
                        projectiles.splice(i, 1);
                    }
                    continue; // Spout effect doesn't move
                }

                p.x += p.dirX * p.speed; // Use projectile's individual speed
                p.y += p.dirY * p.speed; // Use projectile's individual speed

                // Remove projectiles that are off-screen
                if (p.x < -p.size || p.x > canvas.width + p.size || p.y < -p.size || p.y > canvas.height + p.size) {
                    projectiles.splice(i, 1);
                }
            }

            // Power-up logic
            if (!powerup.active && (currentTime - powerup.lastCollectedTime > powerup.spawnDelay)) {
                spawnPowerup(); // Spawn if not active and delay passed
            }

            if (powerup.active) {
                // Check for collision with player
                // Note: Using player.size as an approximation for frog's collision radius
                if (checkCollision(player, {x: powerup.x, y: powerup.y, size: powerup.size})) {
                    activateRapidFire(5000); // Activate for 5 seconds
                    powerup.active = false; // Deactivate power-up
                    powerup.lastCollectedTime = currentTime; // Record collection time
                }
            }

            // Enemy spawning logic
            if (currentTime - lastEnemySpawnTime > enemySpawnInterval) {
                spawnEnemy();
                lastEnemySpawnTime = currentTime;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Apply status effects (slow, burn) - Placeholder for now, will be implemented later
                if (enemy.isSlowed) {
                    // console.log(`${enemy.type} is slowed.`);
                }
                if (enemy.isBurning) {
                    // console.log(`${enemy.type} is burning.`);
                }

                let targetX = player.x;
                let targetY = player.y;
                let effectiveEnemySpeed = enemy.originalSpeed * currentGlobalSpeedMultiplier; // Apply global speed multiplier

                // AI Logic based on enemy.aiType
                if (enemy.aiType === 'zombie_wander') {
                    // If target retention time is over or very close to the last known position, reacquire target
                    if (currentTime >= enemy.reacquireTargetTime ||
                        (Math.abs(enemy.x - enemy.lastKnownPlayerX) < effectiveEnemySpeed && Math.abs(enemy.y - enemy.lastKnownPlayerY) < effectiveEnemySpeed)) {
                        enemy.lastKnownPlayerX = player.x;
                        enemy.lastKnownPlayerY = player.y;
                        enemy.reacquireTargetTime = currentTime + ZOMBIE_TARGET_RETENTION_DURATION;
                    }
                    targetX = enemy.lastKnownPlayerX;
                    targetY = enemy.lastKnownPlayerY;
                } else if (enemy.aiType === 'dragon_evade') {
                    const dx_to_player = player.x - enemy.x;
                    const dy_to_player = player.y - enemy.y;
                    const distance_to_player = Math.sqrt(dx_to_player * dx_to_player + dy_to_player * dy_to_player);

                    let move_dx = dx_to_player;
                    let move_dy = dy_to_player;

                    if (mouse.isMouseDown && distance_to_player > 0) { // If player is shooting, try to evade
                        // Get player's aiming direction
                        const dx_aim = reticle.x - player.x;
                        const dy_aim = reticle.y - player.y;
                        const aim_magnitude = Math.sqrt(dx_aim * dx_aim + dy_aim * dy_aim);

                        if (aim_magnitude > 0) {
                            const unit_dx_aim = dx_aim / aim_magnitude;
                            const unit_dy_aim = dy_aim / aim_magnitude;

                            // Perpendicular vector (one direction, can be randomly flipped for more variation)
                            // For simplicity, we'll just use one perpendicular direction.
                            const perp_dx = -unit_dy_aim;
                            const perp_dy = unit_dx_aim;

                            // Blend direct movement with evasion movement
                            // Add a weighted perpendicular component to the movement towards the player
                            // This makes it "strafe" while still moving generally towards the player
                            move_dx = dx_to_player + perp_dx * DRAGON_EVASION_STRENGTH * enemy.size; // Scale evasion by enemy size for effect
                            move_dy = dy_to_player + perp_dy * DRAGON_EVASION_STRENGTH * enemy.size;
                        }
                    }
                    const move_magnitude = Math.sqrt(move_dx * move_dx + move_dy * move_dy);
                    if (move_magnitude > 0) {
                        enemy.x += (move_dx / move_magnitude) * effectiveEnemySpeed;
                        enemy.y += (move_dy / move_magnitude) * effectiveEnemySpeed;
                    } else {
                        // Fallback if evasion logic results in zero movement (unlikely but safe)
                        targetX = player.x;
                        targetY = player.y;
                    }
                } else if (enemy.aiType === 'ghost_wavy') {
                    const dx_to_player = player.x - enemy.x;
                    const dy_to_player = player.y - enemy.y;
                    const angle_to_player = Math.atan2(dy_to_player, dx_to_player);

                    // Calculate perpendicular direction for wavy movement
                    const perp_dx = Math.cos(angle_to_player + Math.PI / 2);
                    const perp_dy = Math.sin(angle_to_player + Math.PI / 2);

                    // Apply sine wave to the perpendicular movement
                    const waveOffset = GHOST_WAVE_AMPLITUDE * Math.sin(currentTime * GHOST_WAVE_FREQUENCY + enemy.waveOffset);

                    // Blend direct movement with wavy movement
                    targetX = enemy.x + dx_to_player + perp_dx * waveOffset;
                    targetY = enemy.y + dy_to_player + perp_dy * waveOffset;

                    // Normalize the combined movement vector
                    const combined_dx = targetX - enemy.x;
                    const combined_dy = targetY - enemy.y;
                    const combined_distance = Math.sqrt(combined_dx * combined_dx + combined_dy * combined_dy);

                    if (combined_distance > 0) {
                        enemy.x += (combined_dx / combined_distance) * effectiveEnemySpeed;
                        enemy.y += (combined_dy / combined_distance) * effectiveEnemySpeed;
                    }

                } else if (enemy.aiType === 'bone_devil_charge') {
                    // Bone Devil AI states: 'moving', 'pausing', 'charging'
                    switch (enemy.aiState) {
                        case 'moving':
                            // Move towards player normally
                            const dx = player.x - enemy.x;
                            const dy = player.y - enemy.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > 0) {
                                enemy.x += (dx / distance) * effectiveEnemySpeed;
                                enemy.y += (dy / distance) * effectiveEnemySpeed;
                            }

                            // Transition to pausing after a certain distance or time, or randomly
                            if (distance < 100 || Math.random() < 0.005) { // If close or random chance
                                enemy.aiState = 'pausing';
                                enemy.stateTimer = currentTime;
                            }
                            break;
                        case 'pausing':
                            // Stay still
                            if (currentTime - enemy.stateTimer > BONE_DEVIL_PAUSE_DURATION) {
                                enemy.aiState = 'charging';
                                enemy.stateTimer = currentTime;
                                // Store target for charge
                                enemy.chargeTargetX = player.x;
                                enemy.chargeTargetY = player.y;
                            }
                            break;
                        case 'charging':
                            // Move rapidly towards stored charge target
                            const charge_dx = enemy.chargeTargetX - enemy.x;
                            const charge_dy = enemy.chargeTargetY - enemy.y;
                            const charge_distance = Math.sqrt(charge_dx * charge_dx + charge_dy * charge_dy);

                            if (charge_distance > 0) {
                                enemy.x += (charge_dx / charge_distance) * (effectiveEnemySpeed * BONE_DEVIL_CHARGE_SPEED_MULTIPLIER);
                                enemy.y += (charge_dy / charge_distance) * (effectiveEnemySpeed * BONE_DEVIL_CHARGE_SPEED_MULTIPLIER);
                            }

                            // Transition back to moving after charge duration or if target reached
                            if (currentTime - enemy.stateTimer > BONE_DEVIL_CHARGE_DURATION || charge_distance < enemy.size) {
                                enemy.aiState = 'moving';
                            }
                            break;
                    }
                } else { // 'direct' AI type (Skull, and others by default)
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        enemy.x += (dx / distance) * effectiveEnemySpeed;
                        enemy.y += (dy / distance) * effectiveEnemySpeed;
                    }
                }


                // Check for player-enemy collisions
                if (checkCollision(player, enemy)) {
                    player.health -= playerDamagePerCollision; // Player takes damage
                    enemies.splice(i, 1); // Remove the enemy after collision
                    if (player.health <= 0) {
                        player.health = 0; // Cap health at 0
                        gameState = 'gameOver';
                        finalScoreDisplay.textContent = score;
                        gameOverScreen.style.display = 'flex'; // Show game over screen
                        // Hide game elements when game is over/won
                        document.querySelector('.top-hud').style.display = 'none';
                        document.querySelector('.controls-info').style.display = 'none';
                        canvas.style.display = 'none';
                        gameTitle.style.display = 'block'; // Show title again on game over/win
                        touchMovementOverlay.classList.remove('active'); // Hide touch overlay
                    }
                    continue; // Skip projectile collision check for this enemy as it's removed
                }

                // Check for projectile-enemy collisions
                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const p = projectiles[j];

                    // Skip spout_effect as it's purely visual and its damage is applied instantly
                    if (p.type === 'spout_effect') continue;

                    // Collision check considers the enemy's actual size
                    if (checkCollision(p, enemy)) {
                        enemy.health -= p.damage; // Reduce enemy health by projectile damage
                        projectiles.splice(j, 1); // Remove the projectile
                        
                        // Apply specific weapon effects on hit (placeholders for now)
                        if (p.effect === 'slow') {
                            // Logic for slowing enemy
                            console.log(`Frost hit ${enemy.type}!`);
                        } else if (p.effect === 'burn') {
                            // Logic for burning enemy
                            console.log(`Ignition hit ${enemy.type}!`);
                        }

                        if (enemy.health <= 0) {
                            score += enemy.points; // Add points to score
                            enemies.splice(i, 1); // Remove the enemy if health is 0
                            break; // Break inner loop as enemy is removed
                        }
                    }
                }
            }
            updateHUD(); // Update HUD elements in the DOM
        }

        // Function to draw everything on the canvas
        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Only draw game elements if playing
            if (gameState === 'playing') {
                // Draw player
                drawPlayer();

                // Draw reticle
                drawReticle();

                // Draw projectiles
                projectiles.forEach(p => {
                    // Use the weapon's defined draw function for the projectile
                    // For 'spout_effect', we use a generic draw function that pulses
                    if (p.type === 'spout_effect') {
                        // Draw a pulsating circle for the AOE effect
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * (0.5 + 0.5 * Math.abs(Math.sin(performance.now() / 100))), 0, Math.PI * 2); // Pulsating effect
                        ctx.fill();
                    } else {
                        // Find the weapon definition to get its draw function
                        const weaponDef = weapons.find(w => w.name === p.type);
                        if (weaponDef && weaponDef.draw) {
                            weaponDef.draw(ctx, p);
                        } else {
                            // Fallback draw for unknown projectile types
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });

                // Draw power-up
                drawPowerup();

                // Draw enemies
                enemies.forEach(enemy => {
                    drawEnemy(enemy); // Call the main drawEnemy function
                });
            }
            // HUD is now DOM elements, no need to draw on canvas
        }

        // Function to render the weapon selector in the DOM
        function renderWeaponSelector() {
            console.log("renderWeaponSelector called");
            weaponSelectorContainer.innerHTML = ''; // Clear existing icons
            weapons.forEach((weapon, index) => {
                const weaponIconDiv = document.createElement('div');
                weaponIconDiv.classList.add('weapon-icon');
                weaponIconDiv.innerHTML = weapon.icon;
                if (index === currentWeaponIndex) {
                    weaponIconDiv.classList.add('selected');
                }
                weaponIconDiv.addEventListener('click', () => {
                    // Allow clicking to switch weapons too
                    currentWeaponIndex = index;
                    currentWeapon = weapons[currentWeaponIndex];
                    currentFireRate = rapidFireActive ? currentWeapon.fireRateFactor * rapidFireRate : currentWeapon.fireRateFactor * baseFireRate;
                    renderWeaponSelector(); // Re-render to update highlight
                });
                weaponSelectorContainer.appendChild(weaponIconDiv);
            });
            console.log("weaponSelectorContainer innerHTML:", weaponSelectorContainer.innerHTML);
        }

        // Function to update the HUD elements in the DOM
        function updateHUD() {
            // Update Health Bar
            const healthPercentage = (player.health / player.maxHealth) * 100;
            healthBarInner.style.width = `${healthPercentage}%`;
            healthBarText.textContent = `Health: ${player.health}/${player.maxHealth}`;

            // Update EXP
            expDisplay.textContent = `EXP: ${score}`;

            // Update Timer
            const minutes = Math.floor(gameTimer / 60);
            const seconds = Math.floor(gameTimer % 60).toString().padStart(2, '0');
            timerDisplay.textContent = `Time: ${minutes}:${seconds}`;
        }


        // Main game loop
        function gameLoop() {
            update(); // Update game state
            draw();   // Draw everything
            requestAnimationFrame(gameLoop); // Request next frame
        }

        // Start the game loop when the window loads
        window.onload = function () {
            setCanvasSize(); // Set initial canvas size and player/reticle positions
            window.addEventListener('resize', setCanvasSize); // Add resize listener after initial setup

            // Initially hide game elements and show title screen
            document.querySelector('.top-hud').style.display = 'none';
            document.querySelector('.controls-info').style.display = 'none';
            canvas.style.display = 'none';
            titleScreen.style.display = 'flex'; // Ensure title screen is visible
            gameTitle.style.display = 'block'; // Ensure the main game title is visible initially
            touchMovementOverlay.classList.remove('active'); // Ensure touch overlay is hidden initially

            gameLoop(); // Start the loop, but it will only update/draw if gameState is 'playing'
        };
    </script>
</body>
</html>
