<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laser Shooter Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a2e; /* Dark background */
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
        }

        canvas {
            background-color: #0f0f1a; /* Slightly lighter dark for game area */
            display: block;
            border: 2px solid #00bfff; /* Neon blue border */
            border-radius: 15px; /* Rounded corners for the game area */
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.7); /* Glow effect */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #2e003a; /* Darker background for the container */
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5); /* Purple glow */
        }

        h1 {
            color: #e0e0e0;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .controls-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #cccccc;
            text-align: center;
        }

        .powerup-status {
            margin-top: 10px;
            font-size: 1em;
            color: #00ff7f; /* Neon green for active status */
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 127, 0.6);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Laser Shooter</h1>
        <canvas id="gameCanvas"></canvas>
        <div class="controls-info">
            <p><strong>Controls:</strong></p>
            <p>Move: <strong>W A S D</strong></p>
            <p>Aim: <strong>Mouse</strong></p>
            <p>Shoot: <strong>Left Click (Hold for continuous fire!)</strong></p>
        </div>
        <div id="powerupStatus" class="powerup-status" style="display: none;">
            RAPID FIRE ACTIVE!
        </div>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get the power-up status element
        const powerupStatus = document.getElementById('powerupStatus');

        // Set canvas dimensions (responsive)
        const setCanvasSize = () => {
            canvas.width = Math.min(window.innerWidth * 0.9, 800); // Max 800px width
            canvas.height = Math.min(window.innerHeight * 0.7, 600); // Max 600px height
        };
        setCanvasSize(); // Set initial size
        window.addEventListener('resize', setCanvasSize); // Adjust on resize

        // Player properties
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 30, // Base size for the frog
            speed: 5,
            color: '#32CD32' // Lime Green for the frog
        };

        // Reticle properties
        const reticle = {
            x: player.x,
            y: player.y,
            size: 10,
            color: '#ff00ff' // Neon magenta
        };

        // Array to hold active lasers
        const lasers = [];

        // Laser properties
        const laserSpeed = 10;
        const laserColor = '#00ffff'; // Cyan
        const laserSize = 5;

        // Firing rate properties
        let baseFireRate = 8; // Lasers per second (normal rate)
        let rapidFireRate = 20; // Lasers per second (power-up rate)
        let currentFireRate = baseFireRate;
        let lastShotTime = 0; // Timestamp of the last shot
        let rapidFireActive = false;
        let rapidFireTimeoutId = null; // To clear the timeout

        // Power-up object properties
        const powerup = {
            x: 0,
            y: 0,
            size: 20,
            color: '#FFFF00', // Yellow
            active: false,
            spawnDelay: 5000, // 5 seconds before next spawn
            lastCollectedTime: 0
        };

        // Keyboard input state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // Mouse input state
        let mouse = {
            x: 0,
            y: 0,
            isMouseDown: false
        };

        // --- Event Listeners ---

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = true;
            if (e.key === 'a' || e.key === 'A') keys.a = true;
            if (e.key === 's' || e.key === 'S') keys.s = true;
            if (e.key === 'd' || e.key === 'D') keys.d = true;
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = false;
            if (e.key === 'a' || e.key === 'A') keys.a = false;
            if (e.key === 's' || e.key === 'S') keys.s = false;
            if (e.key === 'd' || e.key === 'D') keys.d = false;
        });

        // Mouse movement for reticle
        canvas.addEventListener('mousemove', (e) => {
            // Get mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            reticle.x = e.clientX - rect.left;
            reticle.y = e.clientY - rect.top;
        });

        // Mouse click for shooting (continuous firing handled in gameLoop)
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left mouse button
                mouse.isMouseDown = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mouse.isMouseDown = false;
            }
        });

        // Touch events for mobile (basic movement and shooting)
        // This provides very basic touch support. For a full mobile game,
        // you'd typically implement on-screen joysticks/buttons.
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveX = 0;
        let touchMoveY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;

            // Activate continuous firing on touch start
            mouse.isMouseDown = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchMoveX = touch.clientX - rect.left;
            touchMoveY = touch.clientY - rect.top;

            // Update reticle position based on touch move
            reticle.x = touchMoveX;
            reticle.y = touchMoveY;

            // Simple player movement based on touch drag relative to player
            const dx = touchMoveX - player.x;
            const dy = touchMoveY - player.y;

            // Normalize direction for movement
            const angle = Math.atan2(dy, dx);
            keys.d = Math.abs(Math.cos(angle)) > 0.5 && Math.cos(angle) > 0;
            keys.a = Math.abs(Math.cos(angle)) > 0.5 && Math.cos(angle) < 0;
            keys.s = Math.abs(Math.sin(angle)) > 0.5 && Math.sin(angle) > 0;
            keys.w = Math.abs(Math.sin(angle)) > 0.5 && Math.sin(angle) < 0;
        });

        canvas.addEventListener('touchend', (e) => {
            // Stop movement and firing when touch ends
            keys.w = keys.a = keys.s = keys.d = false;
            mouse.isMouseDown = false;
        });

        // --- Game Functions ---

        // Function to draw the player (frog with moving eyes!)
        function drawPlayer() {
            ctx.fillStyle = player.color;

            // Draw frog body (main ellipse) - centered at player.x, player.y
            ctx.beginPath();
            ctx.ellipse(player.x, player.y, player.size * 0.7, player.size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Frog eye properties
            const eyeRadius = player.size * 0.2;
            const eyeOffsetX = player.size * 0.3;
            const eyeOffsetY = -player.size * 0.4; // Eyes are above the body relative to player.y

            // Left eye stalk position
            const leftEyeX = player.x - eyeOffsetX;
            const leftEyeY = player.y + eyeOffsetY;

            // Right eye stalk position
            const rightEyeX = player.x + eyeOffsetX;
            const rightEyeY = player.y + eyeOffsetY;

            // Draw left eye stalk
            ctx.beginPath();
            ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw right eye stalk
            ctx.beginPath();
            ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw pupils (black circles)
            ctx.fillStyle = 'black';
            const pupilRadius = eyeRadius * 0.4;
            const maxPupilOffset = eyeRadius - pupilRadius; // Max distance pupil can move from eye center

            // Calculate angle from player to reticle (for pupil direction)
            const angleToReticle = Math.atan2(reticle.y - player.y, reticle.x - player.x);

            // Calculate pupil offset based on angle
            const pupilDx = Math.cos(angleToReticle) * maxPupilOffset;
            const pupilDy = Math.sin(angleToReticle) * maxPupilOffset;

            // Draw left pupil
            ctx.beginPath();
            ctx.arc(leftEyeX + pupilDx, leftEyeY + pupilDy, pupilRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw right pupil
            ctx.beginPath();
            ctx.arc(rightEyeX + pupilDx, rightEyeY + pupilDy, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Function to draw the reticle
        function drawReticle() {
            ctx.strokeStyle = reticle.color;
            ctx.lineWidth = 2;

            // Draw a crosshair reticle
            ctx.beginPath();
            ctx.moveTo(reticle.x - reticle.size, reticle.y);
            ctx.lineTo(reticle.x + reticle.size, reticle.y);
            ctx.moveTo(reticle.x, reticle.y - reticle.size);
            ctx.lineTo(reticle.x, reticle.y + reticle.size);
            ctx.stroke();

            // Draw a small circle in the center
            ctx.beginPath();
            ctx.arc(reticle.x, reticle.y, reticle.size / 3, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Function to draw the power-up
        function drawPowerup() {
            if (powerup.active) {
                ctx.fillStyle = powerup.color;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, powerup.size, 0, Math.PI * 2);
                ctx.fill();

                // Add a pulsating glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = powerup.color;
                ctx.globalAlpha = 0.8 + 0.2 * Math.sin(performance.now() / 200); // Pulsating effect
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
                ctx.globalAlpha = 1; // Reset alpha
            }
        }

        // Function to shoot a laser
        function shootLaser() {
            const currentTime = performance.now();
            const timeSinceLastShot = currentTime - lastShotTime;
            const requiredTimeBetweenShots = 1000 / currentFireRate; // Milliseconds per shot

            // Only shoot if enough time has passed since the last shot
            if (timeSinceLastShot >= requiredTimeBetweenShots) {
                // Calculate direction vector from player to reticle
                const dx = reticle.x - player.x;
                const dy = reticle.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Normalize the direction vector
                const dirX = dx / distance;
                const dirY = dy / distance;

                // Add a new laser to the array
                lasers.push({
                    x: player.x,
                    y: player.y,
                    dirX: dirX,
                    dirY: dirY,
                    color: laserColor,
                    size: laserSize
                });

                lastShotTime = currentTime; // Update last shot time
            }
        }

        // Function to activate rapid fire power-up
        function activateRapidFire(duration) {
            if (rapidFireActive) {
                clearTimeout(rapidFireTimeoutId); // Clear any existing timeout if power-up is re-activated
            }

            currentFireRate = rapidFireRate; // Set to rapid fire rate
            rapidFireActive = true;
            powerupStatus.style.display = 'block'; // Show status message

            // Set a timeout to revert to base fire rate after duration
            rapidFireTimeoutId = setTimeout(() => {
                currentFireRate = baseFireRate; // Revert to base rate
                rapidFireActive = false;
                powerupStatus.style.display = 'none'; // Hide status message
            }, duration);
        }

        // Function to spawn a power-up at a random location
        function spawnPowerup() {
            if (!powerup.active) { // Only spawn if not already active
                powerup.x = Math.random() * (canvas.width - powerup.size * 2) + powerup.size;
                powerup.y = Math.random() * (canvas.height - powerup.size * 2) + powerup.size;
                powerup.active = true;
            }
        }

        // Function to check for collision between two circles
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size + obj2.size); // Collision if distance is less than sum of radii
        }

        // Function to update game state (movement, laser positions, power-up)
        function update() {
            // Update player position based on keys pressed
            if (keys.w) player.y -= player.speed;
            if (keys.s) player.y += player.speed;
            if (keys.a) player.x -= player.speed;
            if (keys.d) player.x += player.speed;

            // Keep player within canvas bounds
            player.x = Math.max(player.size * 0.7, Math.min(canvas.width - player.size * 0.7, player.x));
            player.y = Math.max(player.size * 0.5, Math.min(canvas.height - player.size * 0.5, player.y));


            // If mouse is down, continuously try to shoot
            if (mouse.isMouseDown) {
                shootLaser();
            }

            // Update laser positions
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.x += laser.dirX * laserSpeed;
                laser.y += laser.dirY * laserSpeed;

                // Remove lasers that are off-screen
                if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
                    lasers.splice(i, 1);
                }
            }

            // Power-up logic
            if (!powerup.active && (performance.now() - powerup.lastCollectedTime > powerup.spawnDelay)) {
                spawnPowerup(); // Spawn if not active and delay passed
            }

            if (powerup.active) {
                // Check for collision with player
                // Note: Using player.size as an approximation for frog's collision radius
                if (checkCollision(player, {x: powerup.x, y: powerup.y, size: powerup.size})) {
                    activateRapidFire(5000); // Activate for 5 seconds
                    powerup.active = false; // Deactivate power-up
                    powerup.lastCollectedTime = performance.now(); // Record collection time
                }
            }
        }

        // Function to draw everything on the canvas
        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            drawPlayer();

            // Draw reticle
            drawReticle();

            // Draw lasers
            lasers.forEach(laser => {
                ctx.fillStyle = laser.color;
                ctx.beginPath();
                ctx.arc(laser.x, laser.y, laser.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw power-up
            drawPowerup();
        }

        // Main game loop
        function gameLoop() {
            update(); // Update game state
            draw();   // Draw everything
            requestAnimationFrame(gameLoop); // Request next frame
        }

        // Start the game loop when the window loads
        window.onload = function () {
            // Initial spawn of power-up after a short delay
            setTimeout(spawnPowerup, 1000);
            gameLoop();
        };
    </script>
</body>
</html>
