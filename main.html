<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laser Shooter Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a2e; /* Dark background */
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
        }

        canvas {
            background-color: #0f0f1a; /* Slightly lighter dark for game area */
            display: block;
            border: 2px solid #00bfff; /* Neon blue border */
            border-radius: 15px; /* Rounded corners for the game area */
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.7); /* Glow effect */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #2e003a; /* Darker background for the container */
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5); /* Purple glow */
        }

        h1 {
            color: #e0e0e0;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .controls-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #cccccc;
            text-align: center;
        }

        .powerup-status {
            margin-top: 10px;
            font-size: 1em;
            color: #00ff7f; /* Neon green for active status */
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 127, 0.6);
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e0e0e0;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 0, 0, 0.7); /* Red glow for game over */
            border-radius: 15px; /* Match canvas border radius */
            z-index: 10; /* Ensure it's on top */
        }

        .game-over-screen p {
            margin: 10px 0;
        }

        .restart-button {
            background-color: #00bfff; /* Neon blue */
            color: #1a1a2e;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.4);
            margin-top: 20px;
        }

        .restart-button:hover {
            background-color: #00e0ff; /* Lighter blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 191, 255, 0.6);
        }

        .restart-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 191, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Laser Shooter</h1>
        <canvas id="gameCanvas"></canvas>
        <div class="controls-info">
            <p><strong>Controls:</strong></p>
            <p>Move: <strong>W A S D</strong></p>
            <p>Aim: <strong>Mouse</strong></p>
            <p>Shoot: <strong>Left Click (Hold for continuous fire!)</strong></p>
            <p>Switch Weapon: <strong>Spacebar</strong></p>
        </div>
        <div id="powerupStatus" class="powerup-status" style="display: none;">
            RAPID FIRE ACTIVE!
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <p>GAME OVER!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartButton" class="restart-button">Restart Game</button>
        </div>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get HUD elements
        const powerupStatus = document.getElementById('powerupStatus');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // Game state variables
        let gameState = 'playing'; // 'playing' or 'gameOver'
        let score = 0;

        // Set canvas dimensions (responsive)
        const setCanvasSize = () => {
            canvas.width = Math.min(window.innerWidth * 0.9, 800); // Max 800px width
            canvas.height = Math.min(window.innerHeight * 0.7, 600); // Max 600px height
        };
        setCanvasSize(); // Set initial size
        window.addEventListener('resize', setCanvasSize); // Adjust on resize

        // Player properties
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 30, // Base size for the frog
            speed: 5,
            color: '#32CD32', // Lime Green for the frog
            health: 100,
            maxHealth: 100
        };

        // Reticle properties
        const reticle = {
            x: player.x,
            y: player.y,
            size: 10,
            color: '#ff00ff' // Neon magenta
        };

        // Array to hold active lasers (now projectiles)
        const projectiles = [];

        // Weapon definitions
        const weapons = [
            {
                name: 'laser',
                color: '#00ffff', // Cyan
                projectileSize: 5,
                projectileSpeed: 10, // Speed for laser projectile
                fireRateFactor: 1, // Base fire rate
                damage: 1,
                type: 'projectile', // 'projectile' or 'aoe'
                draw: (ctx, p) => { // Needle shape
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.dirY, p.dirX)); // Rotate to direction of travel
                    ctx.fillRect(-p.size * 2, -p.size / 2, p.size * 4, p.size); // Long thin rectangle
                    ctx.restore();
                },
                icon: 'âš¡' // Emoji icon for laser
            },
            {
                name: 'electric',
                color: '#ffdd00', // Yellow
                projectileSize: 3,
                projectileSpeed: 12, // Speed for electric projectile
                fireRateFactor: 2, // Faster firing
                damage: 0.5, // Less damage per shot
                spreadCount: 5, // Number of shots in spread
                spreadAngle: Math.PI / 8, // Angle of spread
                type: 'projectile',
                draw: (ctx, p) => { // Small circle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                },
                icon: 'âš¡' // Emoji icon for electric
            },
            {
                name: 'frost',
                color: '#87ceeb', // Sky Blue
                projectileSize: 15, // Larger projectile
                projectileSpeed: 7, // Slower speed for frost projectile
                fireRateFactor: 0.5, // Slower firing
                damage: 2,
                effect: 'slow',
                effectDuration: 3000, // 3 seconds slow
                slowFactor: 0.5, // Reduce enemy speed by 50%
                type: 'projectile',
                draw: (ctx, p) => { // Large blue circle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                },
                icon: 'â„ï¸' // Emoji icon for frost
            },
            {
                name: 'ignition',
                color: '#ff4500', // Orange Red
                projectileSize: 7,
                projectileSpeed: 9, // Speed for ignition projectile
                fireRateFactor: 0.7, // Slower firing
                damage: 1, // Initial damage
                effect: 'burn',
                burnDuration: 4000, // 4 seconds burn
                burnDamagePerTick: 0.2, // Damage per tick
                burnTickInterval: 200, // Every 200ms
                type: 'projectile',
                draw: (ctx, p) => { // Fiery circle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                },
                icon: 'ðŸ”¥' // Emoji icon for ignition
            },
            {
                name: 'spout',
                color: '#00bfff', // Deep Sky Blue
                projectileSize: 40, // Area of effect radius
                projectileSpeed: 0, // AOE doesn't move
                fireRateFactor: 0.3, // Very slow firing
                damage: 5, // Damage per enemy in area
                type: 'aoe', // Area of effect weapon
                draw: (ctx, p) => { // Pulsating circle for AOE
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (0.5 + 0.5 * Math.sin(performance.now() / 100)), 0, Math.PI * 2); // Pulsating effect
                    ctx.fill();
                },
                icon: 'ðŸ’§' // Emoji icon for spout
            }
        ];

        let currentWeaponIndex = 0;
        let currentWeapon = weapons[currentWeaponIndex];

        // Firing rate properties
        let baseFireRate = currentWeapon.fireRateFactor * 8; // Adjust base fire rate by weapon factor
        let rapidFireRate = currentWeapon.fireRateFactor * 20; // Adjust rapid fire rate by weapon factor
        let currentFireRate = baseFireRate;
        let lastShotTime = 0; // Timestamp of the last shot
        let rapidFireActive = false;
        let rapidFireTimeoutId = null; // To clear the timeout

        // Power-up object properties
        const powerup = {
            x: 0,
            y: 0,
            size: 20,
            color: '#FFFF00', // Yellow
            active: false,
            spawnDelay: 5000, // 5 seconds before next spawn
            lastCollectedTime: 0
        };

        // Enemy properties
        const enemies = [];
        const enemySpawnInterval = 2000; // Spawn a new enemy every 2 seconds
        let lastEnemySpawnTime = 0;
        const enemyBaseSpeed = 1.5; // Base speed for enemies
        const enemyBaseSize = 25; // Base size for enemies
        const playerDamagePerCollision = 20; // Damage player takes per enemy collision

        // Define different enemy types with their health, size, speed, and points
        const enemyTypes = [
            { name: 'ghost', health: 3, sizeFactor: 1, speedFactor: 1, points: 10 },
            { name: 'zombie', health: 5, sizeFactor: 1.2, speedFactor: 0.8, points: 20 }, // Slower, tankier
            { name: 'skull', health: 2, sizeFactor: 0.8, speedFactor: 1.5, points: 5 }, // Faster, weaker
            { name: 'boneDevil', health: 7, sizeFactor: 1.3, speedFactor: 1.1, points: 30 },
            { name: 'boneDragon', health: 10, sizeFactor: 1.5, speedFactor: 0.7, points: 50 } // Slowest, strongest
        ];

        // Palette of colors for enemies
        const enemyColors = [
            '#b0c4de', // Light steel blue
            '#a9a9a9', // Dark gray
            '#808080', // Gray
            '#696969', // Dim gray
            '#d3d3d3', // Light gray
            '#f0f8ff', // Alice blue (almost white, for ghostly)
            '#add8e6', // Light blue
            '#90ee90', // Light green (decaying)
            '#ffb6c1', // Light pink (flesh, but desaturated)
            '#deb887',  // Burly wood (bone-like)
            '#c0c0c0', // Silver
            '#708090', // Slate Gray
            '#4682b4', // Steel Blue
            '#b22222'  // Firebrick
        ];

        // Function to get a random color from the palette
        function getRandomColor() {
            return enemyColors[Math.floor(Math.random() * enemyColors.length)];
        }

        // Keyboard input state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false // Added for weapon switching
        };

        // Mouse input state
        let mouse = {
            x: 0,
            y: 0,
            isMouseDown: false
        };

        // --- Event Listeners ---

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = true;
            if (e.key === 'a' || e.key === 'A') keys.a = true;
            if (e.key === 's' || e.key === 'S') keys.s = true;
            if (e.key === 'd' || e.key === 'D') keys.d = true;
            if (e.code === 'Space' && !keys.space) { // Only trigger once per press
                keys.space = true;
                switchWeapon();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = false;
            if (e.key === 'a' || e.key === 'A') keys.a = false;
            if (e.key === 's' || e.key === 'S') keys.s = false;
            if (e.key === 'd' || e.key === 'D') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });

        // Mouse movement for reticle
        canvas.addEventListener('mousemove', (e) => {
            // Get mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            reticle.x = e.clientX - rect.left;
            reticle.y = e.clientY - rect.top;
        });

        // Mouse click for shooting (continuous firing handled in gameLoop)
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left mouse button
                mouse.isMouseDown = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mouse.isMouseDown = false;
            }
        });

        // Touch events for mobile (basic movement and shooting)
        // This provides very basic touch support. For a full mobile game,
        // you'd typically implement on-screen joysticks/buttons.
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveX = 0;
        let touchMoveY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;

            // Activate continuous firing on touch start
            mouse.isMouseDown = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchMoveX = touch.clientX - rect.left;
            touchMoveY = touch.clientY - rect.top;

            // Update reticle position based on touch move
            reticle.x = touchMoveX;
            reticle.y = touchMoveY;

            // Simple player movement based on touch drag relative to player
            const dx = touchMoveX - player.x;
            const dy = touchMoveY - player.y;

            // Normalize direction for movement
            const angle = Math.atan2(dy, dx);
            keys.d = Math.abs(Math.cos(angle)) > 0.5 && Math.cos(angle) > 0;
            keys.a = Math.abs(Math.cos(angle)) > 0.5 && Math.cos(angle) < 0;
            keys.s = Math.abs(Math.sin(angle)) > 0.5 && Math.sin(angle) > 0;
            keys.w = Math.abs(Math.sin(angle)) > 0.5 && Math.sin(angle) < 0;
        });

        canvas.addEventListener('touchend', (e) => {
            // Stop movement and firing when touch ends
            keys.w = keys.a = keys.s = keys.d = false;
            mouse.isMouseDown = false;
        });

        // Restart button listener
        restartButton.addEventListener('click', () => {
            resetGame();
        });

        // --- Game Functions ---

        // Function to draw the player (frog with moving eyes!)
        function drawPlayer() {
            ctx.fillStyle = player.color;

            // Draw frog body (main ellipse) - centered at player.x, player.y
            ctx.beginPath();
            ctx.ellipse(player.x, player.y, player.size * 0.7, player.size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Frog eye properties
            const eyeRadius = player.size * 0.2;
            const eyeOffsetX = player.size * 0.3;
            const eyeOffsetY = -player.size * 0.4; // Eyes are above the body relative to player.y

            // Left eye stalk position
            const leftEyeX = player.x - eyeOffsetX;
            const leftEyeY = player.y + eyeOffsetY;

            // Right eye stalk position
            const rightEyeX = player.x + eyeOffsetX;
            const rightEyeY = player.y + eyeOffsetY;

            // Draw left eye stalk
            ctx.beginPath();
            ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw right eye stalk
            ctx.beginPath();
            ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw pupils (black circles)
            ctx.fillStyle = 'black';
            const pupilRadius = eyeRadius * 0.4;
            const maxPupilOffset = eyeRadius - pupilRadius; // Max distance pupil can move from eye center

            // Calculate angle from player to reticle (for pupil direction)
            const angleToReticle = Math.atan2(reticle.y - player.y, reticle.x - player.x);

            // Calculate pupil offset based on angle
            const pupilDx = Math.cos(angleToReticle) * maxPupilOffset;
            const pupilDy = Math.sin(angleToReticle) * maxPupilOffset;

            // Draw left pupil
            ctx.beginPath();
            ctx.arc(leftEyeX + pupilDx, leftEyeY + pupilDy, pupilRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw right pupil
            ctx.beginPath();
            ctx.arc(rightEyeX + pupilDx, rightEyeY + pupilDy, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Function to draw the reticle
        function drawReticle() {
            ctx.strokeStyle = reticle.color;
            ctx.lineWidth = 2;

            // Draw a crosshair reticle
            ctx.beginPath();
            ctx.moveTo(reticle.x - reticle.size, reticle.y);
            ctx.lineTo(reticle.x + reticle.size, reticle.y);
            ctx.moveTo(reticle.x, reticle.y - reticle.size);
            ctx.lineTo(reticle.x, reticle.y + reticle.size);
            ctx.stroke();

            // Draw a small circle in the center
            ctx.beginPath();
            ctx.arc(reticle.x, reticle.y, reticle.size / 3, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Function to draw the power-up
        function drawPowerup() {
            if (powerup.active) {
                ctx.fillStyle = powerup.color;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, powerup.size, 0, Math.PI * 2);
                ctx.fill();

                // Add a pulsating glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = powerup.color;
                ctx.globalAlpha = 0.8 + 0.2 * Math.sin(performance.now() / 200); // Pulsating effect
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
                ctx.globalAlpha = 1; // Reset alpha
            }
        }

        // --- Drawing functions for different enemy types ---

        function drawGhostShape(ctx, enemy) {
            const bodyWidth = enemy.size * 1.5;
            const bodyHeight = enemy.size * 1.8;
            const bottomCurveRadius = enemy.size * 0.5;

            ctx.beginPath();
            // Top rectangle part
            ctx.moveTo(enemy.x - bodyWidth / 2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x + bodyWidth / 2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x + bodyWidth / 2, enemy.y + bodyHeight / 2 - bottomCurveRadius);

            // Bottom curves (scallops)
            const numScallops = 3;
            const scallopWidth = bodyWidth / numScallops;
            for (let i = 0; i < numScallops; i++) {
                const startX = enemy.x - bodyWidth / 2 + i * scallopWidth;
                ctx.arc(startX + scallopWidth / 2, enemy.y + bodyHeight / 2 - bottomCurveRadius, scallopWidth / 2, 0, Math.PI, true);
            }
            ctx.lineTo(enemy.x - bodyWidth / 2, enemy.y + bodyHeight / 2 - bottomCurveRadius);
            ctx.closePath();
            ctx.fill();

            // Draw ghost eyes (simple circles)
            ctx.fillStyle = 'black';
            const eyeRadius = enemy.size * 0.2;
            ctx.beginPath();
            ctx.arc(enemy.x - enemy.size * 0.4, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + enemy.size * 0.4, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawZombieShape(ctx, enemy) {
            const bodyWidth = enemy.size * 1.2;
            const bodyHeight = enemy.size * 1.8;
            const headSize = enemy.size * 0.8;

            // Body
            ctx.beginPath();
            ctx.rect(enemy.x - bodyWidth / 2, enemy.y - bodyHeight / 2, bodyWidth, bodyHeight);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y - bodyHeight / 2 - headSize / 2, headSize / 2, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'darkred';
            const eyeRadius = headSize * 0.15;
            ctx.beginPath();
            ctx.arc(enemy.x - headSize * 0.25, enemy.y - bodyHeight / 2 - headSize / 2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + headSize * 0.25, enemy.y - bodyHeight / 2 - headSize / 2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (simple line)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(enemy.x - headSize * 0.2, enemy.y - bodyHeight / 2 - headSize / 2 + headSize * 0.2);
            ctx.lineTo(enemy.x + headSize * 0.2, enemy.y - bodyHeight / 2 - headSize / 2 + headSize * 0.2);
            ctx.stroke();
        }

        function drawSkullShape(ctx, enemy) {
            const skullRadius = enemy.size * 0.8;
            const jawHeight = enemy.size * 0.4;

            // Skull head
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y - jawHeight / 2, skullRadius, 0, Math.PI * 2);
            ctx.fill();

            // Jaw (simple rectangle)
            ctx.beginPath();
            ctx.rect(enemy.x - skullRadius * 0.7, enemy.y - jawHeight / 2 + skullRadius * 0.8, skullRadius * 1.4, jawHeight);
            ctx.fill();

            // Eye sockets
            ctx.fillStyle = 'black';
            const eyeSocketRadius = skullRadius * 0.25;
            ctx.beginPath();
            ctx.arc(enemy.x - skullRadius * 0.35, enemy.y - jawHeight / 2 - skullRadius * 0.2, eyeSocketRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + skullRadius * 0.35, enemy.y - jawHeight / 2 - skullRadius * 0.2, eyeSocketRadius, 0, Math.PI * 2);
            ctx.fill();

            // Nose hole (triangle)
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - jawHeight / 2 + skullRadius * 0.2);
            ctx.lineTo(enemy.x - skullRadius * 0.1, enemy.y - jawHeight / 2 + skullRadius * 0.4);
            ctx.lineTo(enemy.x + skullRadius * 0.1, enemy.y - jawHeight / 2 + skullRadius * 0.4);
            ctx.closePath();
            ctx.fill();
        }

        function drawBoneDevilShape(ctx, enemy) {
            const bodyWidth = enemy.size * 1.6;
            const bodyHeight = enemy.size * 1.5;
            const hornLength = enemy.size * 0.7;

            // Main body (trapezoid/diamond-like)
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - bodyHeight / 2); // Top point
            ctx.lineTo(enemy.x + bodyWidth / 2, enemy.y); // Right point
            ctx.lineTo(enemy.x, enemy.y + bodyHeight / 2); // Bottom point
            ctx.lineTo(enemy.x - bodyWidth / 2, enemy.y); // Left point
            ctx.closePath();
            ctx.fill();

            // Horns
            ctx.beginPath();
            ctx.moveTo(enemy.x - bodyWidth * 0.2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x - bodyWidth * 0.2 - hornLength * 0.5, enemy.y - bodyHeight / 2 - hornLength);
            ctx.lineTo(enemy.x - bodyWidth * 0.2 + hornLength * 0.2, enemy.y - bodyHeight / 2);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(enemy.x + bodyWidth * 0.2, enemy.y - bodyHeight / 2);
            ctx.lineTo(enemy.x + bodyWidth * 0.2 + hornLength * 0.5, enemy.y - bodyHeight / 2 - hornLength);
            ctx.lineTo(enemy.x + bodyWidth * 0.2 - hornLength * 0.2, enemy.y - bodyHeight / 2);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'red'; // Fiery eyes
            const eyeRadius = enemy.size * 0.15;
            ctx.beginPath();
            ctx.arc(enemy.x - enemy.size * 0.3, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + enemy.size * 0.3, enemy.y - enemy.size * 0.3, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBoneDragonShape(ctx, enemy) {
            const bodyLength = enemy.size * 3;
            const bodyHeight = enemy.size * 0.8;
            const headRadius = enemy.size * 0.6;

            // Body (elongated ellipse)
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y, bodyLength / 2, bodyHeight / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (at one end of the body)
            ctx.beginPath();
            ctx.arc(enemy.x + bodyLength / 2 - headRadius * 0.5, enemy.y - headRadius * 0.2, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Spikes along the back
            ctx.fillStyle = enemy.color; // Use body color for spikes
            const numSpikes = 5;
            for (let i = 0; i < numSpikes; i++) {
                const spikeX = enemy.x - bodyLength / 2 + (i + 0.5) * (bodyLength / numSpikes);
                const spikeY = enemy.y - bodyHeight / 2;
                const spikeHeight = enemy.size * 0.4;
                const spikeWidth = enemy.size * 0.2;

                ctx.beginPath();
                ctx.moveTo(spikeX - spikeWidth / 2, spikeY);
                ctx.lineTo(spikeX + spikeWidth / 2, spikeY);
                ctx.lineTo(spikeX, spikeY - spikeHeight);
                ctx.closePath();
                ctx.fill();
            }

            // Eyes
            ctx.fillStyle = 'darkred';
            const eyeRadius = headRadius * 0.15;
            ctx.beginPath();
            ctx.arc(enemy.x + bodyLength / 2 - headRadius * 0.5 - headRadius * 0.2, enemy.y - headRadius * 0.2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + bodyLength / 2 - headRadius * 0.5 + headRadius * 0.2, enemy.y - headRadius * 0.2 - eyeRadius, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Main function to draw an enemy based on its type
        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.globalAlpha = 1; // Ensure full opacity for enemies

            switch (enemy.type) {
                case 'ghost':
                    drawGhostShape(ctx, enemy);
                    break;
                case 'zombie':
                    drawZombieShape(ctx, enemy);
                    break;
                case 'skull':
                    drawSkullShape(ctx, enemy);
                    break;
                case 'boneDevil':
                    drawBoneDevilShape(ctx, enemy);
                    break;
                case 'boneDragon':
                    drawBoneDragonShape(ctx, enemy);
                    break;
                default:
                    // Fallback: draw a simple circle if type is unknown
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }


        // Function to fire the current weapon
        function fireWeapon() {
            const currentTime = performance.now();
            const timeSinceLastShot = currentTime - lastShotTime;
            const requiredTimeBetweenShots = 1000 / currentFireRate; // Milliseconds per shot

            // Only fire if enough time has passed since the last shot
            if (timeSinceLastShot >= requiredTimeBetweenShots) {
                // Calculate direction vector from player to reticle
                const dx = reticle.x - player.x;
                const dy = reticle.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Normalize the direction vector
                const dirX = dx / distance;
                const dirY = dy / distance;

                if (currentWeapon.type === 'projectile') {
                    if (currentWeapon.name === 'electric') {
                        // Electric: multiple spread shots
                        const numShots = currentWeapon.spreadCount;
                        const baseAngle = Math.atan2(dirY, dirX);
                        for (let i = 0; i < numShots; i++) {
                            const angleOffset = (i - (numShots - 1) / 2) * (currentWeapon.spreadAngle / numShots);
                            const newAngle = baseAngle + angleOffset;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                dirX: Math.cos(newAngle),
                                dirY: Math.sin(newAngle),
                                color: currentWeapon.color,
                                size: currentWeapon.projectileSize,
                                speed: currentWeapon.projectileSpeed, // Assign projectile speed
                                damage: currentWeapon.damage,
                                type: currentWeapon.name,
                                effect: currentWeapon.effect // Will be undefined for electric, which is fine
                            });
                        }
                    } else {
                        // Default projectile (laser, frost, ignition)
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            dirX: dirX,
                            dirY: dirY,
                            color: currentWeapon.color,
                            size: currentWeapon.projectileSize,
                            speed: currentWeapon.projectileSpeed, // Assign projectile speed
                            damage: currentWeapon.damage,
                            type: currentWeapon.name,
                            effect: currentWeapon.effect // For frost/ignition
                        });
                    }
                } else if (currentWeapon.type === 'aoe' && currentWeapon.name === 'spout') {
                    // Spout: instantaneous AOE at reticle
                    // No projectile, directly apply damage to enemies in area
                    enemies.forEach(enemy => {
                        if (checkCollision(enemy, {x: reticle.x, y: reticle.y, size: currentWeapon.projectileSize})) {
                            enemy.health -= currentWeapon.damage;
                            // Add visual feedback for AOE hit (e.g., temporary particle effect)
                            // For now, just a console log
                            console.log(`Enemy hit by Spout: ${enemy.type}, new health: ${enemy.health}`);
                        }
                    });
                    // Add a temporary visual effect for spout at the reticle
                    projectiles.push({
                        x: reticle.x,
                        y: reticle.y,
                        size: currentWeapon.projectileSize,
                        color: currentWeapon.color,
                        type: 'spout_effect', // Special type for drawing only
                        duration: 200 // How long the visual effect lasts
                    });
                }

                lastShotTime = currentTime; // Update last shot time
            }
        }

        // Function to activate rapid fire power-up
        function activateRapidFire(duration) {
            if (rapidFireActive) {
                clearTimeout(rapidFireTimeoutId); // Clear any existing timeout if power-up is re-activated
            }

            // Calculate rapid fire rate based on current weapon's factor
            currentFireRate = currentWeapon.fireRateFactor * rapidFireRate;
            rapidFireActive = true;
            powerupStatus.style.display = 'block'; // Show status message

            // Set a timeout to revert to base fire rate after duration
            rapidFireTimeoutId = setTimeout(() => {
                currentFireRate = currentWeapon.fireRateFactor * baseFireRate; // Revert to base rate
                rapidFireActive = false;
                powerupStatus.style.display = 'none'; // Hide status message
            }, duration);
        }

        // Function to switch weapon
        function switchWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % weapons.length;
            currentWeapon = weapons[currentWeaponIndex];
            // Update fire rate based on new weapon's factor
            currentFireRate = rapidFireActive ? currentWeapon.fireRateFactor * rapidFireRate : currentWeapon.fireRateFactor * baseFireRate;
        }


        // Function to spawn a power-up at a random location
        function spawnPowerup() {
            if (!powerup.active) { // Only spawn if not already active
                powerup.x = Math.random() * (canvas.width - powerup.size * 2) + powerup.size;
                powerup.y = Math.random() * (canvas.height - powerup.size * 2) + powerup.size;
                powerup.active = true;
            }
        }

        // Function to spawn an enemy from off-screen
        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y;

            const chosenType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            // Adjust spawn position based on the actual size of the enemy to ensure it's fully off-screen
            const spawnOffset = enemyBaseSize * chosenType.sizeFactor * 2; // Use actual size for offset

            switch (side) {
                case 0: // Top
                    x = Math.random() * canvas.width;
                    y = -spawnOffset;
                    break;
                case 1: // Right
                    x = canvas.width + spawnOffset;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // Bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + spawnOffset;
                    break;
                case 3: // Left
                    x = -spawnOffset;
                    y = Math.random() * canvas.height;
                    break;
            }

            enemies.push({
                x: x,
                y: y,
                size: enemyBaseSize * chosenType.sizeFactor, // Apply size factor
                color: getRandomColor(),
                speed: enemyBaseSpeed * chosenType.speedFactor, // Apply speed factor
                health: chosenType.health,
                type: chosenType.name, // Store the type name for drawing
                points: chosenType.points, // Store points for scoring
                // Status effects
                isSlowed: false,
                slowTimer: 0,
                originalSpeed: enemyBaseSpeed * chosenType.speedFactor, // Store original speed
                isBurning: false,
                burnTimer: 0,
                burnDamagePerTick: 0,
                lastBurnTickTime: 0
            });
        }

        // Function to check for collision between two circles
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size + obj2.size); // Collision if distance is less than sum of radii
        }

        // Function to reset game state for a new game
        function resetGame() {
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            score = 0;
            enemies.length = 0; // Clear all enemies
            projectiles.length = 0; // Clear all projectiles
            powerup.active = false; // Deactivate power-up
            currentWeaponIndex = 0; // Reset to default weapon
            currentWeapon = weapons[currentWeaponIndex];
            currentFireRate = baseFireRate; // Reset fire rate
            rapidFireActive = false;
            if (rapidFireTimeoutId) clearTimeout(rapidFireTimeoutId);
            powerupStatus.style.display = 'none';
            gameOverScreen.style.display = 'none';
            gameState = 'playing';
            lastEnemySpawnTime = performance.now(); // Reset enemy spawn timer
            powerup.lastCollectedTime = performance.now(); // Reset powerup spawn timer
            // Spawn initial power-up after a short delay
            setTimeout(spawnPowerup, 1000);
        }

        // Function to update game state (movement, projectile positions, power-up, enemies)
        function update() {
            if (gameState !== 'playing') return; // Do not update if game is over

            // Update player position based on keys pressed
            if (keys.w) player.y -= player.speed;
            if (keys.s) player.y += player.speed;
            if (keys.a) player.x -= player.speed;
            if (keys.d) player.x += player.speed;

            // Keep player within canvas bounds
            player.x = Math.max(player.size * 0.7, Math.min(canvas.width - player.size * 0.7, player.x));
            player.y = Math.max(player.size * 0.5, Math.min(canvas.height - player.size * 0.5, player.y));


            // If mouse is down, continuously try to fire weapon
            if (mouse.isMouseDown) {
                fireWeapon();
            }

            // Update projectile positions
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];

                if (p.type === 'spout_effect') {
                    p.duration -= 16; // Assuming 60fps, roughly 16ms per frame
                    if (p.duration <= 0) {
                        projectiles.splice(i, 1);
                    }
                    continue; // Spout effect doesn't move
                }

                p.x += p.dirX * p.speed; // Use projectile's individual speed
                p.y += p.dirY * p.speed; // Use projectile's individual speed

                // Remove projectiles that are off-screen
                if (p.x < -p.size || p.x > canvas.width + p.size || p.y < -p.size || p.y > canvas.height + p.size) {
                    projectiles.splice(i, 1);
                }
            }

            // Power-up logic
            if (!powerup.active && (performance.now() - powerup.lastCollectedTime > powerup.spawnDelay)) {
                spawnPowerup(); // Spawn if not active and delay passed
            }

            if (powerup.active) {
                // Check for collision with player
                // Note: Using player.size as an approximation for frog's collision radius
                if (checkCollision(player, {x: powerup.x, y: powerup.y, size: powerup.size})) {
                    activateRapidFire(5000); // Activate for 5 seconds
                    powerup.active = false; // Deactivate power-up
                    powerup.lastCollectedTime = performance.now(); // Record collection time
                }
            }

            // Enemy logic
            const currentTime = performance.now();
            if (currentTime - lastEnemySpawnTime > enemySpawnInterval) {
                spawnEnemy();
                lastEnemySpawnTime = currentTime;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Apply status effects (slow, burn)
                if (enemy.isSlowed) {
                    // This will be handled in a later update for actual effect application
                }
                if (enemy.isBurning) {
                    // This will be handled in a later update for actual effect application
                }

                // Move enemy towards the player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed; // Use enemy's individual speed
                    enemy.y += (dy / distance) * enemy.speed; // Use enemy's individual speed
                }

                // Check for player-enemy collisions
                if (checkCollision(player, enemy)) {
                    player.health -= playerDamagePerCollision; // Player takes damage
                    enemies.splice(i, 1); // Remove the enemy after collision
                    if (player.health <= 0) {
                        player.health = 0; // Cap health at 0
                        gameState = 'gameOver';
                        finalScoreDisplay.textContent = score;
                        gameOverScreen.style.display = 'flex'; // Show game over screen
                    }
                    continue; // Skip projectile collision check for this enemy as it's removed
                }

                // Check for projectile-enemy collisions
                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const p = projectiles[j];

                    // Skip spout_effect as it's purely visual and its damage is applied instantly
                    if (p.type === 'spout_effect') continue;

                    // Collision check considers the enemy's actual size
                    if (checkCollision(p, enemy)) {
                        enemy.health -= p.damage; // Reduce enemy health by projectile damage
                        projectiles.splice(j, 1); // Remove the projectile
                        
                        // Apply specific weapon effects on hit (placeholders for now)
                        if (p.effect === 'slow') {
                            // Logic for slowing enemy
                            console.log(`Frost hit ${enemy.type}!`);
                        } else if (p.effect === 'burn') {
                            // Logic for burning enemy
                            console.log(`Ignition hit ${enemy.type}!`);
                        }

                        if (enemy.health <= 0) {
                            score += enemy.points; // Add points to score
                            enemies.splice(i, 1); // Remove the enemy if health is 0
                            break; // Break inner loop as enemy is removed
                        }
                    }
                }
            }
        }

        // Function to draw everything on the canvas
        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            drawPlayer();

            // Draw reticle
            drawReticle();

            // Draw projectiles
            projectiles.forEach(p => {
                // Use the weapon's defined draw function for the projectile
                // For 'spout_effect', we use a generic draw function that pulses
                if (p.type === 'spout_effect') {
                    // Draw a pulsating circle for the AOE effect
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (0.5 + 0.5 * Math.abs(Math.sin(performance.now() / 100))), 0, Math.PI * 2); // Pulsating effect
                    ctx.fill();
                } else {
                    // Find the weapon definition to get its draw function
                    const weaponDef = weapons.find(w => w.name === p.type);
                    if (weaponDef && weaponDef.draw) {
                        weaponDef.draw(ctx, p);
                    } else {
                        // Fallback draw for unknown projectile types
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });

            // Draw power-up
            drawPowerup();

            // Draw enemies
            enemies.forEach(enemy => {
                drawEnemy(enemy); // Call the main drawEnemy function
            });

            // Draw HUD
            drawHUD();
        }

        // Function to draw the HUD (Health Bar, Score, and Weapon Selector)
        function drawHUD() {
            // Health Bar
            const healthBarWidth = 200;
            const healthBarHeight = 20;
            const healthBarX = 20;
            const healthBarY = 20;

            // Background of health bar
            ctx.fillStyle = '#555'; // Grey background
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            // Current health
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;
            ctx.fillStyle = '#FF0000'; // Red for health
            ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

            // Health bar border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            // Health text
            ctx.fillStyle = '#fff';
            ctx.font = '16px Inter';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Health: ${player.health}/${player.maxHealth}`, healthBarX, healthBarY + healthBarHeight + 5);

            // Score
            ctx.fillStyle = '#fff';
            ctx.font = '24px Inter';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText(`Score: ${score}`, canvas.width - 20, 20);

            // Weapon Selector
            const weaponIconSize = 40;
            const weaponIconPadding = 10;
            const totalWeaponWidth = (weaponIconSize + weaponIconPadding) * weapons.length - weaponIconPadding;
            const startX = (canvas.width / 2) - (totalWeaponWidth / 2);
            const startY = 20; // Position below score/health

            weapons.forEach((weapon, index) => {
                const iconX = startX + index * (weaponIconSize + weaponIconPadding);
                const iconY = startY;

                // Draw background for icon
                ctx.fillStyle = '#333';
                ctx.fillRect(iconX, iconY, weaponIconSize, weaponIconSize);

                // Draw icon text (emoji)
                ctx.font = `${weaponIconSize * 0.7}px Arial`; // Use Arial for emojis
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(weapon.icon, iconX + weaponIconSize / 2, iconY + weaponIconSize / 2);

                // Highlight selected weapon
                if (index === currentWeaponIndex) {
                    ctx.strokeStyle = '#00ff7f'; // Neon green highlight
                    ctx.lineWidth = 3;
                    ctx.strokeRect(iconX, iconY, weaponIconSize, weaponIconSize);
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff7f';
                    ctx.strokeRect(iconX, iconY, weaponIconSize, weaponIconSize); // Draw again for stronger glow
                    ctx.shadowBlur = 0; // Reset shadow
                }
            });
        }


        // Main game loop
        function gameLoop() {
            update(); // Update game state
            draw();   // Draw everything
            requestAnimationFrame(gameLoop); // Request next frame
        }

        // Start the game loop when the window loads
        window.onload = function () {
            resetGame(); // Initialize game state
            gameLoop();
        };
    </script>
</body>
</html>
